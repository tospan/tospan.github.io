<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Unity Curves and Splines | 吐司片的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Curves and Splines, making your own path
This tutorial will take you from creating a simple line all the way to editing your own Beziér splines. You’ll learn to

Create a custom editor;
Draw in the sc">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Curves and Splines">
<meta property="og:url" content="http://tospan.me/2017/02/05/Unity/Curves-and-Splines/index.html">
<meta property="og:site_name" content="吐司片的博客">
<meta property="og:description" content="Curves and Splines, making your own path
This tutorial will take you from creating a simple line all the way to editing your own Beziér splines. You’ll learn to

Create a custom editor;
Draw in the sc">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/curves-and-splines-tutorial-image.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-a-simple-line.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-draw-line.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-editor.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-untransformed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-transformed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-local-rotation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-global-rotation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-local-mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-global-mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-curve.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-straight.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-bezier.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-linear.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-quadratic.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-velocity.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-direction.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-cubic.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-draw-bezier.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-spline.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-adding-a-curve.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-showing-spline.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-directions.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-point-dots.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-fixed-size-dots.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-selected-point.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-colored-points.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-enforced.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-loop-property.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-spline-loop.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-large-begin.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walker.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walking.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-looking-forward.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walking-and-looking.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walk-mode.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorator.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating-no-loop.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating-non-loop-complete.png">
<meta property="og:updated_time" content="2017-02-05T12:17:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unity Curves and Splines">
<meta name="twitter:description" content="Curves and Splines, making your own path
This tutorial will take you from creating a simple line all the way to editing your own Beziér splines. You’ll learn to

Create a custom editor;
Draw in the sc">
<meta name="twitter:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/curves-and-splines-tutorial-image.jpg">
  
    <link rel="alternate" href="/atom.xml" title="吐司片的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">吐司片的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Work hard, play hard.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tospan.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Unity/Curves-and-Splines" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/05/Unity/Curves-and-Splines/" class="article-date">
  <time datetime="2017-02-05T12:17:43.000Z" itemprop="datePublished">2017-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Unity Curves and Splines
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Curves and Splines, making your own path</p>
<p>This tutorial will take you from creating a simple line all the way to editing your own Beziér splines. You’ll learn to</p>
<ul>
<li>Create a custom editor;</li>
<li>Draw in the scene view;</li>
<li>Support editing via the scene view;</li>
<li>Create Beziér curves and understand the math behind them;</li>
<li>Draw curves and their direction of movement.</li>
<li>Build Beziér splines by combining curves;</li>
<li>Support free, aligned, and mirrored control points;</li>
<li>Support looping splines;</li>
<li>Move and place objects along a spline.</li>
</ul>
<p>This tutorial builds on the foundation laid by previous tutorials. If you completed the Maze tutorial then you’re good to go.<br>This tutorial was made with Unity 4.5.2. It might not work for older versions.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/curves-and-splines-tutorial-image.jpg" alt="Fun with splines."></p>
<a id="more"></a>
<h2 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h2><p>Let’s start simple by creating a line component. It needs two points <code>p0</code> and <code>p1</code> which define a line segment that goes from the first to the second.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Line</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Vector3 p0, p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-a-simple-line.png" alt="A simple line"></p>
<p>While we can now create game objects with line components and adjust the points, we don’t see anything in the scene. Let’s provide some useful visual information when our line is selected. We can do this by creating a custom inspector for our component.<br>Editor-related code needs to be placed inside an <code>Editor</code> folder, so create one and put a new <code>LineInspector</code> script in it.<br>The inspector needs to extend <code>UnityEditor.Editor</code>. We also have to give it the <code>UnityEditor.CustomEditor</code> attribute. This lets Unity know that it should use our class instead of the default editor for Line components.</p>
<blockquote>
<p>What does typeof do?<br>The typeof operator is used to get the type object of something, usually a class. You cannot use it with variables, only with explicit type names.<br>Why not just write down the class name? Because that results in a compiler error! The extra step is needed because you’re converting a type into a variable.</p>
<p>Is the Editor folder required?<br>Unity splits projects into multiple parts that are compiled in a specific order. The Editor folder is used to separate everything that’s about the editor from everything that’s not. It’s not included in game builds, and code outside of it cannot access it. For example, while LineInspector knows about Line, the reverse is not true.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEditor;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line">[CustomEditor(<span class="keyword">typeof</span>(Line))]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LineInspector</span> : <span class="title">Editor</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>An empty editor does not change anything. We need to add an OnSceneGUI method, which is a special Unity event method. We can use it to draw stuff in the scene view for our component.<br>The Editor class has a target variable, which is set to the object to be drawn when OnSceneGUI is called. We can cast this variable to a line and then use the Handles utility class to draw a line between our points.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Line line = target <span class="keyword">as</span> Line;</div><div class="line"></div><div class="line">	Handles.color = Color.white;</div><div class="line">	Handles.DrawLine(line.p0, line.p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-draw-line.png" alt="line"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-editor.png" alt="editor"><br>Showing a line.</p>
<p>We now see the line, but it doesn’t take its transform’s settings into account. Moving, rotating, and scaling does not affect them at all. This is because <a href="http://docs.unity3d.com/Documentation/ScriptReference/Handles.html" target="_blank" rel="external">Handles</a> operates in world space while the points are in the local space of the line. We have to explicitly convert the points into world space points.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Line line = target <span class="keyword">as</span> Line;</div><div class="line">	Transform handleTransform = line.transform;</div><div class="line">	Vector3 p0 = handleTransform.TransformPoint(line.p0);</div><div class="line">	Vector3 p1 = handleTransform.TransformPoint(line.p1);</div><div class="line"></div><div class="line">	Handles.color = Color.white;</div><div class="line">	Handles.DrawLine(p0, p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-untransformed.png" alt="untransformed"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-transformed.png" alt="transformed"><br>Untransformed vs. transformed.</p>
<p>Besides showing the line, we can also show position handles for our two points. To do this, we also need our transform’s rotation so we can align them correctly.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Line line = target <span class="keyword">as</span> Line;</div><div class="line">	Transform handleTransform = line.transform;</div><div class="line">	Quaternion handleRotation = handleTransform.rotation;</div><div class="line">	Vector3 p0 = handleTransform.TransformPoint(line.p0);</div><div class="line">	Vector3 p1 = handleTransform.TransformPoint(line.p1);</div><div class="line"></div><div class="line">	Handles.color = Color.white;</div><div class="line">	Handles.DrawLine(p0, p1);</div><div class="line">	Handles.DoPositionHandle(p0, handleRotation);</div><div class="line">	Handles.DoPositionHandle(p1, handleRotation);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Although we now get handles, they do not honor Unity’s pivot rotation mode. Fortunately, we can use <code>Tools.pivotRotation</code> to determine the current mode and set our rotation accordingly.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Quaternion handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">	handleTransform.rotation : Quaternion.identity;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-local-rotation.png" alt="local handles"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-global-rotation.png" alt="global handles"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-local-mode.png" alt="local mode"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-global-mode.png" alt="global mode"><br>Local vs. global pivot rotation.</p>
<p>To make the handles actually work, we need to assign their results back to the line. However, as the handle values are in world space we need to convert them back into the line’s local space with the <code>InverseTransformPoint</code> method. Also, we only need to do this when a point has changed. We can use <code>EditorGUI.BeginChangeCheck</code> and <code>EditorGUI.EndChangeCheck</code> for this. The second method tells us whether a change happened after calling the first method.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">EditorGUI.BeginChangeCheck();</div><div class="line">p0 = Handles.DoPositionHandle(p0, handleRotation);</div><div class="line"><span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">	line.p0 = handleTransform.InverseTransformPoint(p0);</div><div class="line">&#125;</div><div class="line">EditorGUI.BeginChangeCheck();</div><div class="line">p1 = Handles.DoPositionHandle(p1, handleRotation);</div><div class="line"><span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">	line.p1 = handleTransform.InverseTransformPoint(p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can drag our points in the scene view!</p>
<p>There are two additional issues that need attention. First, we cannot undo the drag operations. This is fixed by adding a call to <code>Undo.RecordObject</code> before we make any changes. Second, Unity does not know that a change was made, so for example won’t ask the user to save when quitting. This is remedied with a call to <code>EditorUtility.SetDirty</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  EditorGUI.BeginChangeCheck();</div><div class="line">p0 = Handles.DoPositionHandle(p0, handleRotation);</div><div class="line"><span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">	Undo.RecordObject(line, <span class="string">"Move Point"</span>);</div><div class="line">	EditorUtility.SetDirty(line);</div><div class="line">	line.p0 = handleTransform.InverseTransformPoint(p0);</div><div class="line">&#125;</div><div class="line">EditorGUI.BeginChangeCheck();</div><div class="line">p1 = Handles.DoPositionHandle(p1, handleRotation);</div><div class="line"><span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">	Undo.RecordObject(line, <span class="string">"Move Point"</span>);</div><div class="line">	EditorUtility.SetDirty(line);</div><div class="line">	line.p1 = handleTransform.InverseTransformPoint(p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h2><p>It is time to upgrade to curves. A curve is like a line, but it doesn’t need to be straight. Specifically, we’ll create a Beziér curve.<br>A Beziér curve is defined by a sequence of points. It starts at the first point and ends at the last point, but does not need to go through the intermediate points. Instead, those points pull the curve away from being a straight line.<br>Create a new BezierCurve component and give it an array of points. Also give it a Reset method that initializes it with three points. This method also functions as a special Unity method, which is called by the editor when the component is created or reset.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BezierCurve</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Vector3[] points;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		points = <span class="keyword">new</span> Vector3[] &#123;</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">1</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">2</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">3</span>f, <span class="number">0</span>f, <span class="number">0</span>f)</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We also create an inspector for the curve, based on <code>LineInspector</code>. To reduce code repetition, we move the code that shows a point to a separate ShowPoint method that we can call with an index. We also turn curve, handleTransform, and handleRotation into class variables so we don’t need to pass then to ShowPoint.<br>While it is a new script, I’ve marked the differences as if we modified <code>LineInspector</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEditor;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line">[CustomEditor(<span class="keyword">typeof</span>(BezierCurve))]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BezierCurveInspector</span> : <span class="title">Editor</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> BezierCurve curve;</div><div class="line">	<span class="keyword">private</span> Transform handleTransform;</div><div class="line">	<span class="keyword">private</span> Quaternion handleRotation;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		curve = target <span class="keyword">as</span> BezierCurve;</div><div class="line">		handleTransform = curve.transform;</div><div class="line">		handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">			handleTransform.rotation : Quaternion.identity;</div><div class="line"></div><div class="line">		Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">		Vector3 p1 = ShowPoint(<span class="number">1</span>);</div><div class="line">		Vector3 p2 = ShowPoint(<span class="number">2</span>);</div><div class="line"></div><div class="line">		Handles.color = Color.white;</div><div class="line">		Handles.DrawLine(p0, p1);</div><div class="line">		Handles.DrawLine(p1, p2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">		Vector3 point = handleTransform.TransformPoint(curve.points[index]);</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(curve, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(curve);</div><div class="line">			curve.points[index] = handleTransform.InverseTransformPoint(point);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> point;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-curve.png" alt="project"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-straight.png" alt="scene"><br>A 3-point curve.</p>
<p>The idea of Beziér curves is that they are parametric. If you give it a value – typically named <code>t</code> – between zero and one, you get a point on the curve. As <code>t</code> increases from zero to one, you move from the first point of the curve to the last point.<br>To show our curve in the scene, we can approximate it by drawing straight lines between successive steps on the curve. We can do this with a simple loop, assuming our curve has a <code>GetPoint</code> method. We also keep drawing the straight lines between the points, but change their color to gray.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> lineSteps = <span class="number">10</span>;</div><div class="line">		</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	curve = target <span class="keyword">as</span> BezierCurve;</div><div class="line">	handleTransform = curve.transform;</div><div class="line">	handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">		handleTransform.rotation : Quaternion.identity;</div><div class="line"></div><div class="line">	Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">	Vector3 p1 = ShowPoint(<span class="number">1</span>);</div><div class="line">	Vector3 p2 = ShowPoint(<span class="number">2</span>);</div><div class="line"></div><div class="line">	Handles.color = Color.gray;</div><div class="line">	Handles.DrawLine(p0, p1);</div><div class="line">	Handles.DrawLine(p1, p2);</div><div class="line"></div><div class="line">	Handles.color = Color.white;</div><div class="line">	Vector3 lineStart = curve.GetPoint(<span class="number">0</span>f);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineSteps; i++) &#123;</div><div class="line">		Vector3 lineEnd = curve.GetPoint(i / (<span class="keyword">float</span>)lineSteps);</div><div class="line">		Handles.DrawLine(lineStart, lineEnd);</div><div class="line">		lineStart = lineEnd;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we have to add the <code>GetPoint</code> method to BezierCurve otherwise it won’t compile. Here we again make an assumption, this time that there’s a utility Beziér class that does the calculation for any sequence of points. We feed it our points and transform the result to world space.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetPoint</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(Bezier.GetPoint(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>So we add a static Bezier class with the required method. For now, let’s ignore the middle point and simply linearly interpolate between the first and last point.</p>
<blockquote>
<p>How does Vector3.Lerp work?<br>The Vector3.Lerp method performs a linear interpolation between two vectors or points. Linear interpolation means you start at the first value and end at the second value, moving in a straight line at constant velocity between them.<br>Mathematically, such interpolation is done by providing a parameter – usually named t – that specifies how far along this process we are. It starts at zero and ends at one.<br>So the result of Vector3.Lerp(a, b, 0f) should be a, the result of Vector3.Lerp(a, b, 1f) should be b, and the result of Vector3.Lerp(a, b, 0.5f) should be the average of them. This is done by multiplying the first argument by (1f - t), multiplying the second argument by t, and then adding them.<br>As this is only valid when t is in the 0–1 range, it is clamped as well.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Bezier</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetPoint</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> Vector3.Lerp(p0, p2, t);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-bezier.png" alt="bezier"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-linear.png" alt="linear"><br>Beziér library and linear interpolation.</p>
<p>Of course, linear interpolation between the end points totally ignores the middle point. So how do we incorporate the middle point? The answer is to interpolate more than once. First, linearly interpolate between the first and middle point, and also between the middle and last point. That gives us two new points. Linearly interpolating between those two gives us the final point on the curve.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetPoint</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> Vector3.Lerp(Vector3.Lerp(p0, p1, t), Vector3.Lerp(p1, p2, t), t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-quadratic.png" alt=""><br>A quadratic Beziér curve.</p>
<p>This kind of curve is known as a quadratic Beziér curve, because of the polynomial math involved.<br>The linear curve can be written as <strong>B(t) = (1 - t) P0 + t P1</strong>.<br>One step deeper you get <strong>B(t) = (1 - t) ((1 - t) P0 + t P1) + t ((1 - t) P1 + t P2)</strong>. This is really just the linear curve with P0 and P1 replaced by two new linear curves. It can also be rewritten into the more compact form <strong>B(t) = (1 - t)2 P0 + 2 (1 - t) t P1 + t2 P2</strong>. （要详细看看公式，这边有平方）<br>So we could use the quadratic formula instead of three calls to <code>Vector3.Lerp</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetPoint</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	t = Mathf.Clamp01(t);</div><div class="line">	<span class="keyword">float</span> oneMinusT = <span class="number">1</span>f - t;</div><div class="line">	<span class="keyword">return</span></div><div class="line">		oneMinusT * oneMinusT * p0 +</div><div class="line">		<span class="number">2</span>f * oneMinusT * t * p1 +</div><div class="line">		t * t * p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now that we have a polynomial function, we can also describe its derivatives. The first derivative of our quadratic Beziér curve is <code>B&#39;(t) = 2 (1 - t) (P1 - P0) + 2 t (P2 - P1)</code>. Let’s add it.</p>
<blockquote>
<p>What’s a derivative?<br>A derivative of a function measures its rate of change, and is a function itself as well.<br>For example, the function f(t) = 3 is constant, so its derivative is f’(t) = 0.<br>Another example, f(t) = t is linear, so its rate of change is constant f’(t) = 1. Compare this with f(t) = 2 t, which has derivative f’(t) = 2.<br>Jumping to a quadratic function, f(t) = t2 has a linear derivative, f’(t) = 2 t, which means it keeps growing faster.<br>Combinations work too. f(t) = t2 + 3 t + 4 has derivative f’(t) = 2 t + 3 + 0.<br>In general, tn becomes n t(n - 1) as long as n is larger than zero. There are more complex rules as well, but you don’t need those to deal with derivatives of Beziér curves.<br>So how do we get the first derivative of B(t) = (1 - t)2 P0 + 2 (1 - t) t P1 + t2 P2?<br>Note that (1 - t)2 rewrites to t2 - 2 t + 1, which has derivative 2 t - 2. And 2 (1 - t) t rewrites to 2 t - 2 t2, which has derivative 2 - 4 t.<br>So we end up with B’(t) = (2 t - 2) P0 + (2 - 4 t) P1 + 2 t P2.<br>Then we rewrite it somewhat, turning the P1 part into -(2 t - 2) P1 - 2 t P1. This allows us to combine it with the P0 and P2 parts so we get B’(t) = (2 t - 2) (P0 - P1) + 2 t (P2 - P1).<br>As a last step we invert the first term and extract 2 so we get the nice B’(t) = 2 (1 - t) (P1 - P0) + 2 t (P2 - P1).</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetFirstDerivative</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span></div><div class="line">		<span class="number">2</span>f * (<span class="number">1</span>f - t) * (p1 - p0) +</div><div class="line">		<span class="number">2</span>f * t * (p2 - p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This function produces lines tangent to the curve, which can be interpreted as the speed with which we move along the curve. So now we can add a <code>GetVelocity</code> method to <code>BezierCurve</code>.<br>Because it produces a velocity vector and not a point, it should not be affected by the position of the curve, so we subtract that after transforming.</p>
<blockquote>
<p>What about the second derivative?<br>The second derivative is the derivative of the first derivative, which defines the acceleration – the change of velocity – along the curve. For the quadratic Beziér curve, it is B’’(t) = 2 (P2 - 2 P1 + P0). As t is not part of the formula, quadratic curves have a constant acceleration.</p>
<p>Why not use TransformDirection?<br>The TransformDirection method only takes the object’s rotation into account, but we also need to apply its scale. So we transform our vector as if it were a point and then undo the positioning. This way it always produces the correct velocity, even when using a negative scale.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetVelocity</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(Bezier.GetFirstDerivative(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], t)) -</div><div class="line">		transform.position;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can visualize the speed along the curve in BezierCurveInspector’s OnSceneGUI method.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Vector3 lineStart = curve.GetPoint(<span class="number">0</span>f);</div><div class="line">Handles.color = Color.green;</div><div class="line">Handles.DrawLine(lineStart, lineStart + curve.GetVelocity(<span class="number">0</span>f));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineSteps; i++) &#123;</div><div class="line">	Vector3 lineEnd = curve.GetPoint(i / (<span class="keyword">float</span>)lineSteps);</div><div class="line">	Handles.color = Color.white;</div><div class="line">	Handles.DrawLine(lineStart, lineEnd);</div><div class="line">	Handles.color = Color.green;</div><div class="line">	Handles.DrawLine(lineEnd, lineEnd + curve.GetVelocity(i / (<span class="keyword">float</span>)lineSteps));</div><div class="line">	lineStart = lineEnd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-velocity.png" alt=""><br>Showing velocity.</p>
<p>We can clearly see how the velocity changes along the curve, but those long lines are cluttering the view. Instead of showing the velocity, we can suffice with showing the direction of movement.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Vector3 lineStart = curve.GetPoint(<span class="number">0</span>f);</div><div class="line">Handles.color = Color.green;</div><div class="line">Handles.DrawLine(lineStart, lineStart + curve.GetDirection(<span class="number">0</span>f));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineSteps; i++) &#123;</div><div class="line">	Vector3 lineEnd = curve.GetPoint(i / (<span class="keyword">float</span>)lineSteps);</div><div class="line">	Handles.color = Color.white;</div><div class="line">	Handles.DrawLine(lineStart, lineEnd);</div><div class="line">	Handles.color = Color.green;</div><div class="line">	Handles.DrawLine(lineEnd, lineEnd + curve.GetDirection(i / (<span class="keyword">float</span>)lineSteps));</div><div class="line">	lineStart = lineEnd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Which requires that we add GetDirection to BezierCurve, which simply normalizes the velocity.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetDirection</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> GetVelocity(t).normalized;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-direction.png" alt=""><br>Showing direction.</p>
<p>Let’s go a step further and add new methods to Bezier for cubic curves as well! It works just like the quadratic version, except that it needs a fourth point and its formula goes another step deeper, resulting in a combination of six linear interpolations. The consolidated function of that becomes <strong>B(t) = (1 - t)3 P0 + 3 (1 - t)2 t P1 + 3 (1 - t) t2 P2 + t3 P3</strong> which has as its first derivative <strong>B’(t) = 3 (1 - t)2 (P1 - P0) + 6 (1 - t) t (P2 - P1) + 3 t2 (P3 - P2)</strong>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetPoint</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	t = Mathf.Clamp01(t);</div><div class="line">	<span class="keyword">float</span> oneMinusT = <span class="number">1</span>f - t;</div><div class="line">	<span class="keyword">return</span></div><div class="line">		oneMinusT * oneMinusT * oneMinusT * p0 +</div><div class="line">		<span class="number">3</span>f * oneMinusT * oneMinusT * t * p1 +</div><div class="line">		<span class="number">3</span>f * oneMinusT * t * t * p2 +</div><div class="line">		t * t * t * p3;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetFirstDerivative</span> (<span class="params">Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, <span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	t = Mathf.Clamp01(t);</div><div class="line">	<span class="keyword">float</span> oneMinusT = <span class="number">1</span>f - t;</div><div class="line">	<span class="keyword">return</span></div><div class="line">		<span class="number">3</span>f * oneMinusT * oneMinusT * (p1 - p0) +</div><div class="line">		<span class="number">6</span>f * oneMinusT * t * (p2 - p1) +</div><div class="line">		<span class="number">3</span>f * t * t * (p3 - p2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>With that, we can upgrade BezierCurve from quadratic to cubic by taking an additional point into consideration. Be sure to add the fourth point to its array either manually or by resetting the component.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetPoint</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(Bezier.GetPoint(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>], t));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetVelocity</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(</div><div class="line">		Bezier.GetFirstDerivative(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>], t)) - transform.position;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	points = <span class="keyword">new</span> Vector3[] &#123;</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">1</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">2</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">3</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">4</span>f, <span class="number">0</span>f, <span class="number">0</span>f)</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BezierCurveInspector</code> now needs to be updated so it shows the fourth point as well.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">Vector3 p1 = ShowPoint(<span class="number">1</span>);</div><div class="line">Vector3 p2 = ShowPoint(<span class="number">2</span>);</div><div class="line">Vector3 p3 = ShowPoint(<span class="number">3</span>);</div><div class="line"></div><div class="line">Handles.color = Color.gray;</div><div class="line">Handles.DrawLine(p0, p1);</div><div class="line">Handles.DrawLine(p2, p3);</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-cubic.png" alt=""><br>A cubic Beziér curve.</p>
<p>It is probably visually obvious by now that we draw our curve using straight line segments. We could increase the number of steps to improve the visual quality. We could also use an iterative approach to get accurate down to pixel level. But we can also use Unity’s Handles.DrawBezier method, which takes care of drawing nice cubic Beziér curves for us.<br>Let’s also show the directions in their own method and scale them to take up less space.</p>
<blockquote>
<p>How does DrawBezier work?<br>The method is a bit weird in that its parameter list begins with the end points, followed by the two intermediate points. The middle points are named tangents, but they are expected to be actual control points and not direction vectors.<br>The color argument is obvious, but it also expects a texture and a width. The width is in pixels and should be 2 if you want an anti-aliased look. The texture also needs to be of a specific form to allow anti-aliasing, though the default works fine and I always supply null.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> directionScale = <span class="number">0.5</span>f;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	curve = target <span class="keyword">as</span> BezierCurve;</div><div class="line">	handleTransform = curve.transform;</div><div class="line">	handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">		handleTransform.rotation : Quaternion.identity;</div><div class="line">	</div><div class="line">	Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">	Vector3 p1 = ShowPoint(<span class="number">1</span>);</div><div class="line">	Vector3 p2 = ShowPoint(<span class="number">2</span>);</div><div class="line">	Vector3 p3 = ShowPoint(<span class="number">3</span>);</div><div class="line">	</div><div class="line">	Handles.color = Color.gray;</div><div class="line">	Handles.DrawLine(p0, p1);</div><div class="line">	Handles.DrawLine(p2, p3);</div><div class="line">	</div><div class="line">	ShowDirections();</div><div class="line">	Handles.DrawBezier(p0, p3, p1, p2, Color.white, <span class="literal">null</span>, <span class="number">2</span>f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDirections</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Handles.color = Color.green;</div><div class="line">	Vector3 point = curve.GetPoint(<span class="number">0</span>f);</div><div class="line">	Handles.DrawLine(point, point + curve.GetDirection(<span class="number">0</span>f) * directionScale);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineSteps; i++) &#123;</div><div class="line">		point = curve.GetPoint(i / (<span class="keyword">float</span>)lineSteps);</div><div class="line">		Handles.DrawLine(point, point + curve.GetDirection(i / (<span class="keyword">float</span>)lineSteps) * directionScale);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-draw-bezier.png" alt=""><br>Using Handles.DrawBezier and scaled direction lines.</p>
<h2 id="Splines"><a href="#Splines" class="headerlink" title="Splines"></a>Splines</h2><p>Having a single curve is nice, but to create complex paths we would need to concatenate multiple curves. Such a construct is known as a spline. Let’s create one by copying the <code>BezierCurve</code> code, changing the type to <code>BezierSpline</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BezierSpline</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Vector3[] points;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetPoint</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> transform.TransformPoint(Bezier.GetPoint(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>], t));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetVelocity</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> transform.TransformPoint(</div><div class="line">			Bezier.GetFirstDerivative(points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>], t)) - transform.position;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetDirection</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> GetVelocity(t).normalized;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		points = <span class="keyword">new</span> Vector3[] &#123;</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">1</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">2</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">3</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">			<span class="keyword">new</span> Vector3(<span class="number">4</span>f, <span class="number">0</span>f, <span class="number">0</span>f)</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We also create an editor for it, by copying and tweaking the code from <code>BezierCurveInspector</code>. We can then create a spline object and edit it, just like a curve.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEditor;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line">[CustomEditor(<span class="keyword">typeof</span>(BezierSpline))]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BezierSplineInspector</span> : <span class="title">Editor</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> lineSteps = <span class="number">10</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> directionScale = <span class="number">0.5</span>f;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> BezierSpline spline;</div><div class="line">	<span class="keyword">private</span> Transform handleTransform;</div><div class="line">	<span class="keyword">private</span> Quaternion handleRotation;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">		handleTransform = spline.transform;</div><div class="line">		handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">			handleTransform.rotation : Quaternion.identity;</div><div class="line">		</div><div class="line">		Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">		Vector3 p1 = ShowPoint(<span class="number">1</span>);</div><div class="line">		Vector3 p2 = ShowPoint(<span class="number">2</span>);</div><div class="line">		Vector3 p3 = ShowPoint(<span class="number">3</span>);</div><div class="line">		</div><div class="line">		Handles.color = Color.gray;</div><div class="line">		Handles.DrawLine(p0, p1);</div><div class="line">		Handles.DrawLine(p2, p3);</div><div class="line">		</div><div class="line">		ShowDirections();</div><div class="line">		Handles.DrawBezier(p0, p3, p1, p2, Color.white, <span class="literal">null</span>, <span class="number">2</span>f);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDirections</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		Handles.color = Color.green;</div><div class="line">		Vector3 point = spline.GetPoint(<span class="number">0</span>f);</div><div class="line">		Handles.DrawLine(point, point + spline.GetDirection(<span class="number">0</span>f) * directionScale);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineSteps; i++) &#123;</div><div class="line">			point = spline.GetPoint(i / (<span class="keyword">float</span>)lineSteps);</div><div class="line">			Handles.DrawLine(point, point + spline.GetDirection(i / (<span class="keyword">float</span>)lineSteps) * directionScale);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">		Vector3 point = handleTransform.TransformPoint(spline.points[index]);</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.points[index] = handleTransform.InverseTransformPoint(point);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> point;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-spline.png" alt=""><br>A new spline type.</p>
<p>Let’s add a method to BezierSpline to add another curve to the spline. Because we want the spline to be continuous, the last point of the previous curve is the same as the first point of the next curve. So each extra curve adds three more points.</p>
<blockquote>
<p>What’s ref?<br>The ref keyword indicates that we’re passing an argument by reference. This means that the method is working directly with our value and not a copy of it. So if we provided an integer variable and the method assigned a value to it, then it is our integer that changed. It would be like the method returned the new value and we assigned it to our own variable.<br>The same applies when used with object references. If the method changed the reference, then it is our reference that changed. This means that after the method finished, we could be holding a reference to a different object.<br>You can’t pass a constant value as a ref argument, it must be an initialized variable.<br>There is also an out keyword. It works the same as ref, except that it need not be initialized and enforces that the method assigns a value to it.<br>The ref and out modifiers are typically only used when a method has multiple independent results or when wanting to guarantee that a caller’s variable is assigned to. And sometimes for performance when dealing with large structs. In general, it is to be avoided.</p>
<p>How does Array.Resize work?<br>Array.Resize is a generic method that takes a reference to an array variable, creates a new array of the same type of the given length, and assigns it to the variable. It also copies the contents of the old array to the new array, up to its capacity.<br>So a new array is created and the old one – if there was one – is probably no longer used by anyone and will be taken care of by the garbage collector at some point.<br>Note that it is a generic method, but we didn’t indicate what type to use. The compiler is smart enough to infer the type from the argument and turn it into Array.Resize<vector3>(ref points, points.Length + 3).</vector3></p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCurve</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Vector3 point = points[points.Length - <span class="number">1</span>];</div><div class="line">	Array.Resize(<span class="keyword">ref</span> points, points.Length + <span class="number">3</span>);</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">3</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">2</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">1</span>] = point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We’re using the <code>Array.Resize</code> method to create a larger array to hold the new points. It’s inside the System namespace, so we should declare that we’re using it at the top of our script.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System;</div></pre></td></tr></table></figure>
<p>To actually be able to add a curve, we have to add a button to our spline’s inspector. We can customize the inspector that Unity uses for our component by overriding the OnInspectorGUI method of BezierSplineInspector. Note that this is not a special Unity method, it relies on inheritance.<br>To keep drawing the default inspector, we call the DrawDefaultInspector method. Then we use <code>GUILayout</code> to draw a button, which when clicked adds a curve.</p>
<blockquote>
<p>How does GUILayout.Button work?<br>The Button method both shows a button and returns whether it was clicked. So you typically call it inside an if statement and perform the necessary work in the corresponding code block.<br>What actually happens is that your own GUI method – in this case OnInspectorGUI – gets called far more often than just once. It gets called when performing layout, when repainting, and whenever a significant GUI event happens, which is quite often. Only when a mouse click event comes along that is consumed by the button, will it return true.<br>To get an idea of how often the GUI methods get called, put Debug.Log(Event.current); at the start of your OnInspectorGUI method, then fool around a bit in the editor and watch the console.<br>Usually you need not worry about this, but be aware of it when performing heavy work like generating textures. You don’t want to do that dozens of times per second if you don’t need to.</p>
<p>Why assign spline in both methods?<br>We’re using spline in both OnInspectorGUI and OnSceneGUI, but these two methods basically act independent of one another. OnInspectorGUI is called once for the entire component selection, which could contain multiple objects if we were to support that. OnSceneGUI is called once for each appropriate component in the selection, and each time target changes. So it is best to not have these methods rely on each other.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	DrawDefaultInspector();</div><div class="line">	spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">	<span class="keyword">if</span> (GUILayout.Button(<span class="string">"Add Curve"</span>)) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Add Curve"</span>);</div><div class="line">		spline.AddCurve();</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-adding-a-curve.png" alt=""><br>Adding a curve.</p>
<p>Of course we still only see the first curve. So we adjust BezierSplineInspector so it loops over all the curves.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">	handleTransform = spline.transform;</div><div class="line">	handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">		handleTransform.rotation : Quaternion.identity;</div><div class="line">	</div><div class="line">	Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; spline.points.Length; i += <span class="number">3</span>) &#123;</div><div class="line">		Vector3 p1 = ShowPoint(i);</div><div class="line">		Vector3 p2 = ShowPoint(i + <span class="number">1</span>);</div><div class="line">		Vector3 p3 = ShowPoint(i + <span class="number">2</span>);</div><div class="line">		</div><div class="line">		Handles.color = Color.gray;</div><div class="line">		Handles.DrawLine(p0, p1);</div><div class="line">		Handles.DrawLine(p2, p3);</div><div class="line">		</div><div class="line">		Handles.DrawBezier(p0, p3, p1, p2, Color.white, <span class="literal">null</span>, <span class="number">2</span>f);</div><div class="line">		p0 = p3;</div><div class="line">	&#125;</div><div class="line">	ShowDirections();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-showing-spline.png" alt=""><br>The whole spline.</p>
<p>Now we can see all the curves, but the direction lines are only added to the first one. This is because BezierSpline’s method also still only work with the first curve. It’s time to change that.<br>To cover the entire spline with a t going from zero to one, we fist need to figure out which curve we’re on. We can get the curve’s index by multiplying t by the number of curves and then discarding the fraction. Let’s add a CurveCount property to make that easy.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> CurveCount &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> (points.Length - <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>After that we can reduce t to just the fractional part to get the interpolation value for our curve. To get to the actual points, we have to multiply the curve index by three.<br>However, this would fail when then original t equals one. In this case we can just set it to the last curve.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetPoint</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">if</span> (t &gt;= <span class="number">1</span>f) &#123;</div><div class="line">		t = <span class="number">1</span>f;</div><div class="line">		i = points.Length - <span class="number">4</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		t = Mathf.Clamp01(t) * CurveCount;</div><div class="line">		i = (<span class="keyword">int</span>)t;</div><div class="line">		t -= i;</div><div class="line">		i *= <span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(Bezier.GetPoint(</div><div class="line">		points[i], points[i + <span class="number">1</span>], points[i + <span class="number">2</span>], points[i + <span class="number">3</span>], t));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetVelocity</span> (<span class="params"><span class="keyword">float</span> t</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">if</span> (t &gt;= <span class="number">1</span>f) &#123;</div><div class="line">		t = <span class="number">1</span>f;</div><div class="line">		i = points.Length - <span class="number">4</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		t = Mathf.Clamp01(t) * CurveCount;</div><div class="line">		i = (<span class="keyword">int</span>)t;</div><div class="line">		t -= i;</div><div class="line">		i *= <span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> transform.TransformPoint(Bezier.GetFirstDerivative(</div><div class="line">		points[i], points[i + <span class="number">1</span>], points[i + <span class="number">2</span>], points[i + <span class="number">3</span>], t)) - transform.position;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We now see direction lines across the entire spline, but we can improve the visualization by making sure that each curve segment gets the same amount of lines. Fortunately, it is easy to change <code>BezierSplineInspector.ShowDirections</code> so it uses <code>BezierSpline.CurveCount</code> to determine how many lines to draw.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> stepsPerCurve = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDirections</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Handles.color = Color.green;</div><div class="line">	Vector3 point = spline.GetPoint(<span class="number">0</span>f);</div><div class="line">	Handles.DrawLine(point, point + spline.GetDirection(<span class="number">0</span>f) * directionScale);</div><div class="line">	<span class="keyword">int</span> steps = stepsPerCurve * spline.CurveCount;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= steps; i++) &#123;</div><div class="line">		point = spline.GetPoint(i / (<span class="keyword">float</span>)steps);</div><div class="line">		Handles.DrawLine(point, point + spline.GetDirection(i / (<span class="keyword">float</span>)steps) * directionScale);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-directions.png" alt=""><br>Directions along the entire spline.</p>
<p>It’s rather crowded with all those transform handles. We could only show a handle for the active point. Then then other points can suffice with dots.<br>Let’s update ShowPoint so it shows a button instead of a position handle. This button will look like a white dot, which when clicked will turn into the active point. Then we only show the position handle if the point’s index matches the selected index, which we initialize at -1 so nothing is selected by default.</p>
<blockquote>
<p>How does Handles.Button work?<br>This Button method shows a button in 3D space inside the scene view. Besides a regular size, it also has a pick size. Think of this as the size of the collider used to determine whether the user touches the button. We made it larger than the visible dot so the points are easier to select.<br>Like a few other Handles method, it also needs to be told what shape to draw. This is done by giving it a delete to a draw method. We’re using Handles.DotCap, which draws a square that ignores the rotation and always faces the scene camera.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> handleSize = <span class="number">0.04</span>f;</div><div class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> pickSize = <span class="number">0.06</span>f;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> selectedIndex = <span class="number">-1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	Vector3 point = handleTransform.TransformPoint(spline.points[index]);</div><div class="line">	Handles.color = Color.white;</div><div class="line">	<span class="keyword">if</span> (Handles.Button(point, handleRotation, handleSize, pickSize, Handles.DotCap)) &#123;</div><div class="line">		selectedIndex = index;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex == index) &#123;</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.points[index] = handleTransform.InverseTransformPoint(point);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-point-dots.png" alt=""><br>Showing dots.</p>
<p>This works, but it is tough to get a good size for the dots. Depending on the scale you’re working at, they could end up either too large or too small. It would be nice if we could keep the screen size of the dots fixed, just like the position handles always have the same screen size. We can do this by factoring in <code>HandleUtility.GetHandleSize</code>. This method gives us a fixed screen size for any point in world space.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> size = HandleUtility.GetHandleSize(point);</div><div class="line">Handles.color = Color.white;</div><div class="line"><span class="keyword">if</span> (Handles.Button(point, handleRotation, size * handleSize, size * pickSize, Handles.DotCap)) &#123;</div><div class="line">	selectedIndex = index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-fixed-size-dots.png" alt=""><br>Dots with fixed size.</p>
<h2 id="Constraining-Control-Points"><a href="#Constraining-Control-Points" class="headerlink" title="Constraining Control Points"></a>Constraining Control Points</h2><p>Although our spline is continuous, it sharply changes direction in between curve sections. These sudden changes in direction and speed are possible because the shared control point between two curves has two different velocities associated with it, one for each curve.<br>If we want the velocities to be equal, we must ensure that the two control points that define them – the third of the previous curve and the second of the next curve – mirror each other around the shared point. This ensures that the combined first and second derivatives are continuous.<br>Alternatively, we could align them but let their distance from the shared point differ. That will result in an abrubt change in velocity, while still keeping the direction continuous. In this case the combined first derivative is continuous, but the second is not.<br>The most flexible approach is to decide per curve boundary which contraints should apply, so we’ll do that. Of course, once we have these constraints we can’t just let anyone directly edit BezierSpline’s points. So let’s make our array private and provide indirect access to it. Make sure to let Unity know that we still want to serialize our points, otherwise they won’t be saved.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[SerializeField]</div><div class="line"><span class="keyword">private</span> Vector3[] points;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> ControlPointCount &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> points.Length;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetControlPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> points[index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPoint</span> (<span class="params"><span class="keyword">int</span> index, Vector3 point</span>) </span>&#123;</div><div class="line">	points[index] = point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now BezierSplineInspector must use the new methods and property instead of directly accessing the points array.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">	handleTransform = spline.transform;</div><div class="line">	handleRotation = Tools.pivotRotation == PivotRotation.Local ?</div><div class="line">		handleTransform.rotation : Quaternion.identity;</div><div class="line">	</div><div class="line">	Vector3 p0 = ShowPoint(<span class="number">0</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; spline.ControlPointCount; i += <span class="number">3</span>) &#123;</div><div class="line">		Vector3 p1 = ShowPoint(i);</div><div class="line">		Vector3 p2 = ShowPoint(i + <span class="number">1</span>);</div><div class="line">		Vector3 p3 = ShowPoint(i + <span class="number">2</span>);</div><div class="line">		</div><div class="line">		Handles.color = Color.gray;</div><div class="line">		Handles.DrawLine(p0, p1);</div><div class="line">		Handles.DrawLine(p2, p3);</div><div class="line">		</div><div class="line">		Handles.DrawBezier(p0, p3, p1, p2, Color.white, <span class="literal">null</span>, <span class="number">2</span>f);</div><div class="line">		p0 = p3;</div><div class="line">	&#125;</div><div class="line">	ShowDirections();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	Vector3 point = handleTransform.TransformPoint(spline.GetControlPoint(index));</div><div class="line">	<span class="keyword">float</span> size = HandleUtility.GetHandleSize(point);</div><div class="line">	Handles.color = Color.white;</div><div class="line">	<span class="keyword">if</span> (Handles.Button(point, handleRotation, size * handleSize, size * pickSize, Handles.DotCap)) &#123;</div><div class="line">		selectedIndex = index;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex == index) &#123;</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.SetControlPoint(index, handleTransform.InverseTransformPoint(point));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While we’re at it, we also no longer want to allow direct access to the array in the inspector, so remove the call to <code>DrawDefaultInspector</code>. To still allow changes via typing, let’s show a vector field for the selected point.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">	<span class="keyword">if</span> (selectedIndex &gt;= <span class="number">0</span> &amp;&amp; selectedIndex &lt; spline.ControlPointCount) &#123;</div><div class="line">		DrawSelectedPointInspector();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (GUILayout.Button(<span class="string">"Add Curve"</span>)) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Add Curve"</span>);</div><div class="line">		spline.AddCurve();</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawSelectedPointInspector</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	GUILayout.Label(<span class="string">"Selected Point"</span>);</div><div class="line">	EditorGUI.BeginChangeCheck();</div><div class="line">	Vector3 point = EditorGUILayout.Vector3Field(<span class="string">"Position"</span>, spline.GetControlPoint(selectedIndex));</div><div class="line">	<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">		spline.SetControlPoint(selectedIndex, point);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Unfortunately, it turns out that the inspector doesn’t refresh itself when we select a point in the scene view. We could fix this by calling <code>SetDirty</code> for the spline, but that’s not right because the spline didn’t change. Fortunately, we can issue a repaint request instead.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	Vector3 point = handleTransform.TransformPoint(spline.GetControlPoint(index));</div><div class="line">	<span class="keyword">float</span> size = HandleUtility.GetHandleSize(point);</div><div class="line">	Handles.color = Color.white;</div><div class="line">	<span class="keyword">if</span> (Handles.Button(point, handleRotation, size * handleSize, size * pickSize, Handles.DotCap)) &#123;</div><div class="line">		selectedIndex = index;</div><div class="line">		Repaint();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex == index) &#123;</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.SetControlPoint(index, handleTransform.InverseTransformPoint(point));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-selected-point.png" alt=""><br>Selected point only.</p>
<p>Let’s define an enumeration type to describe our three modes. Create a new script, remove the default code, and define an <code>enum</code> with the three options.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BezierControlPointMode &#123;</div><div class="line">	Free,</div><div class="line">	Aligned,</div><div class="line">	Mirrored</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can add these modes to BezierSpline. We only need to store the mode in between curves, so let’s put them in an array with a length equal to the number of curves plus one. You’ll need to reset your spline or create a new one to make sure you have an array of the right size.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[SerializeField]</div><div class="line"><span class="keyword">private</span> BezierControlPointMode[] modes;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCurve</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Vector3 point = points[points.Length - <span class="number">1</span>];</div><div class="line">	Array.Resize(<span class="keyword">ref</span> points, points.Length + <span class="number">3</span>);</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">3</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">2</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">1</span>] = point;</div><div class="line"></div><div class="line">	Array.Resize(<span class="keyword">ref</span> modes, modes.Length + <span class="number">1</span>);</div><div class="line">	modes[modes.Length - <span class="number">1</span>] = modes[modes.Length - <span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	points = <span class="keyword">new</span> Vector3[] &#123;</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">1</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">2</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">3</span>f, <span class="number">0</span>f, <span class="number">0</span>f),</div><div class="line">		<span class="keyword">new</span> Vector3(<span class="number">4</span>f, <span class="number">0</span>f, <span class="number">0</span>f)</div><div class="line">	&#125;;</div><div class="line">	modes = <span class="keyword">new</span> BezierControlPointMode[] &#123;</div><div class="line">		BezierControlPointMode.Free,</div><div class="line">		BezierControlPointMode.Free</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While we store the modes in between curves, it is convenient if we could get and set modes per control point. So we need to convert a point index into a mode index because in reality points share modes. As an example, the point index sequence 0, 1, 2, 3, 4, 5, 6 corresponds to the mode index sequence 0, 0, 1, 1, 1, 2, 2. So we need to add one and then divide by three.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BezierControlPointMode <span class="title">GetControlPointMode</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> modes[(index + <span class="number">1</span>) / <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPointMode</span> (<span class="params"><span class="keyword">int</span> index, BezierControlPointMode mode</span>) </span>&#123;</div><div class="line">	modes[(index + <span class="number">1</span>) / <span class="number">3</span>] = mode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now BezierSplineInspector can allow us to change the mode of the selected point. You will notice that changing the mode of one point also appears to change the mode of the points that are linked to it.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawSelectedPointInspector</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	GUILayout.Label(<span class="string">"Selected Point"</span>);</div><div class="line">	EditorGUI.BeginChangeCheck();</div><div class="line">	Vector3 point = EditorGUILayout.Vector3Field(<span class="string">"Position"</span>, spline.GetControlPoint(selectedIndex));</div><div class="line">	<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">		spline.SetControlPoint(selectedIndex, point);</div><div class="line">	&#125;</div><div class="line">	EditorGUI.BeginChangeCheck();</div><div class="line">	BezierControlPointMode mode = (BezierControlPointMode)</div><div class="line">		EditorGUILayout.EnumPopup(<span class="string">"Mode"</span>, spline.GetControlPointMode(selectedIndex));</div><div class="line">	<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Change Point Mode"</span>);</div><div class="line">		spline.SetControlPointMode(selectedIndex, mode);</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-mode.png" alt=""><br>Now with adjustable control point mode.</p>
<p>It would be useful if we also got some visual feedback about our node types in the scene view. We can easily add this by coloring the dots. I’ll use white for free, yellow for aligned, and cyan for mirrored.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Color[] modeColors = &#123;</div><div class="line">	Color.white,</div><div class="line">	Color.yellow,</div><div class="line">	Color.cyan</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	Vector3 point = handleTransform.TransformPoint(spline.GetControlPoint(index));</div><div class="line">	<span class="keyword">float</span> size = HandleUtility.GetHandleSize(point);</div><div class="line">	Handles.color = modeColors[(<span class="keyword">int</span>)spline.GetControlPointMode(index)];</div><div class="line">	<span class="keyword">if</span> (Handles.Button(point, handleRotation, size * handleSize, size * pickSize, Handles.DotCap)) &#123;</div><div class="line">		selectedIndex = index;</div><div class="line">		Repaint();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex == index) &#123;</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.SetControlPoint(index, handleTransform.InverseTransformPoint(point));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-colored-points.png" alt=""><br>Now with color-coded points.</p>
<p>So far we’re just coloring points. It’s time to enforce the constraints. We add a new method to BezierSpline to do so and call it when a point is moved or a mode is changed. It takes a point index and begins by retrieving the relevant mode.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPoint</span> (<span class="params"><span class="keyword">int</span> index, Vector3 point</span>) </span>&#123;</div><div class="line">	points[index] = point;</div><div class="line">	EnforceMode(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPointMode</span> (<span class="params"><span class="keyword">int</span> index, BezierControlPointMode mode</span>) </span>&#123;</div><div class="line">	modes[(index + <span class="number">1</span>) / <span class="number">3</span>] = mode;</div><div class="line">	EnforceMode(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnforceMode</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> modeIndex = (index + <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We should check if we actually don’t have to enforce anything. This is the case when the mode is set to free, or when we’re at the end points of the curve. In these cases, we can return without doing anything.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnforceMode</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> modeIndex = (index + <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">	BezierControlPointMode mode = modes[modeIndex];</div><div class="line">	<span class="keyword">if</span> (mode == BezierControlPointMode.Free || modeIndex == <span class="number">0</span> || modeIndex == modes.Length - <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now which point should we adjust? When we change a point’s mode, it is either a point in between curves or one of its neighbors. When we have the middle point selected, we can just keep the previous point fixed and enforce the constraints on the point on the opposite side. If we have one of the other points selected, we should keep that one fixed and adjust its opposite. That way our selected point always stays where it is. So let’s define the indices for these points.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mode == BezierControlPointMode.Free || modeIndex == <span class="number">0</span> || modeIndex == modes.Length - <span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> middleIndex = modeIndex * <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> fixedIndex, enforcedIndex;</div><div class="line"><span class="keyword">if</span> (index &lt;= middleIndex) &#123;</div><div class="line">	fixedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">	enforcedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	fixedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">	enforcedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Let’s consider the mirrored case first. To mirror around the middle point, we have to take the vector from the middle to the fixed point – which is (fixed - middle) – and invert it. This is the enforced tangent, and adding it to the middle gives us our enforced point.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (index &lt;= middleIndex) &#123;</div><div class="line">	fixedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">	enforcedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	fixedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">	enforcedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Vector3 middle = points[middleIndex];</div><div class="line">Vector3 enforcedTangent = middle - points[fixedIndex];</div><div class="line">points[enforcedIndex] = middle + enforcedTangent;</div></pre></td></tr></table></figure>
<p>For the aligned mode, we also have to make sure that the new tangent has the same length as the old one. So we normalize it and then multiply by the distance between the middle and the old enforced point.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vector3 enforcedTangent = middle - points[fixedIndex];</div><div class="line"><span class="keyword">if</span> (mode == BezierControlPointMode.Aligned) &#123;</div><div class="line">	enforcedTangent = enforcedTangent.normalized * Vector3.Distance(middle, points[enforcedIndex]);</div><div class="line">&#125;</div><div class="line">points[enforcedIndex] = middle + enforcedTangent;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-enforced.png" alt=""><br>Enforced constraints.</p>
<p>From now on, whenever you move a point or change a point’s mode, the constraints will be enforced. But when moving a middle point, the previous point always stays fixed and the next point is always enforced. This might be fine, but it’s intuitive if both other points move along with the middle one. So let’s adjust SetControlPoint so it moves them together.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPoint</span> (<span class="params"><span class="keyword">int</span> index, Vector3 point</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (index % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">		Vector3 delta = point - points[index];</div><div class="line">		<span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</div><div class="line">			points[index - <span class="number">1</span>] += delta;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (index + <span class="number">1</span> &lt; points.Length) &#123;</div><div class="line">			points[index + <span class="number">1</span>] += delta;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	points[index] = point;</div><div class="line">	EnforceMode(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>To wrap things up, we should also make sure that the constraints are enforced when we add a curve. We can do this by simply calling EnforceMode at the point where the new curve was added.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCurve</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Vector3 point = points[points.Length - <span class="number">1</span>];</div><div class="line">	Array.Resize(<span class="keyword">ref</span> points, points.Length + <span class="number">3</span>);</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">3</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">2</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">1</span>] = point;</div><div class="line"></div><div class="line">	Array.Resize(<span class="keyword">ref</span> modes, modes.Length + <span class="number">1</span>);</div><div class="line">	modes[modes.Length - <span class="number">1</span>] = modes[modes.Length - <span class="number">2</span>];</div><div class="line">	EnforceMode(points.Length - <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>There is yet another constraint that we could add. By enforcing that the first and last control points share the same position, we can turn our spline into a loop. Of course, we also have to take modes into consideration as well.<br>So let’s add a loop property to BezierSpline. Whenever it is set to true, we make sure the modes of the end points match and wel call SetPosition, trusting that it will take care of the position and mode constraints.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[SerializeField]</div><div class="line"><span class="keyword">private</span> <span class="keyword">bool</span> loop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">bool</span> Loop &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> loop;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">set</span> &#123;</div><div class="line">		loop = <span class="keyword">value</span>;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">true</span>) &#123;</div><div class="line">			modes[modes.Length - <span class="number">1</span>] = modes[<span class="number">0</span>];</div><div class="line">			SetControlPoint(<span class="number">0</span>, points[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can add the loop property to BezierSplineInspector.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	spline = target <span class="keyword">as</span> BezierSpline;</div><div class="line">	EditorGUI.BeginChangeCheck();</div><div class="line">	<span class="keyword">bool</span> loop = EditorGUILayout.Toggle(<span class="string">"Loop"</span>, spline.Loop);</div><div class="line">	<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Toggle Loop"</span>);</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">		spline.Loop = loop;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex &gt;= <span class="number">0</span> &amp;&amp; selectedIndex &lt; spline.ControlPointCount) &#123;</div><div class="line">		DrawSelectedPointInspector();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (GUILayout.Button(<span class="string">"Add Curve"</span>)) &#123;</div><div class="line">		Undo.RecordObject(spline, <span class="string">"Add Curve"</span>);</div><div class="line">		spline.AddCurve();</div><div class="line">		EditorUtility.SetDirty(spline);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-loop-property.png" alt=""><br>Optional loop.</p>
<p>To correctly enforce the loop, we need to make a few more changes to BezierSpline.<br>First, SetControlPointMode needs to make sure that the first and last mode remain equal in case of a loop.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPointMode</span> (<span class="params"><span class="keyword">int</span> index, BezierControlPointMode mode</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> modeIndex = (index + <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">	modes[modeIndex] = mode;</div><div class="line">	<span class="keyword">if</span> (loop) &#123;</div><div class="line">		<span class="keyword">if</span> (modeIndex == <span class="number">0</span>) &#123;</div><div class="line">			modes[modes.Length - <span class="number">1</span>] = mode;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">modeIndex == modes.Length - <span class="number">1</span></span>) </span>&#123;</div><div class="line">			modes[<span class="number">0</span>] = mode;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	EnforceMode(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Next, SetControlPoint needs different edge cases when dealing with a loop, because it needs to wrap around the points array.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetControlPoint</span> (<span class="params"><span class="keyword">int</span> index, Vector3 point</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (index % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">		Vector3 delta = point - points[index];</div><div class="line">		<span class="keyword">if</span> (loop) &#123;</div><div class="line">			<span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">				points[<span class="number">1</span>] += delta;</div><div class="line">				points[points.Length - <span class="number">2</span>] += delta;</div><div class="line">				points[points.Length - <span class="number">1</span>] = point;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">index == points.Length - <span class="number">1</span></span>) </span>&#123;</div><div class="line">				points[<span class="number">0</span>] = point;</div><div class="line">				points[<span class="number">1</span>] += delta;</div><div class="line">				points[index - <span class="number">1</span>] += delta;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				points[index - <span class="number">1</span>] += delta;</div><div class="line">				points[index + <span class="number">1</span>] += delta;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</div><div class="line">				points[index - <span class="number">1</span>] += delta;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (index + <span class="number">1</span> &lt; points.Length) &#123;</div><div class="line">				points[index + <span class="number">1</span>] += delta;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	points[index] = point;</div><div class="line">	EnforceMode(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Next, EnforceMode can now only bail at the end points when not looping. It also has to check whether the fixed or enforced point wraps around the array.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnforceMode</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> modeIndex = (index + <span class="number">1</span>) / <span class="number">3</span>;</div><div class="line">	BezierControlPointMode mode = modes[modeIndex];</div><div class="line">	<span class="keyword">if</span> (mode == BezierControlPointMode.Free || !loop &amp;&amp; (modeIndex == <span class="number">0</span> || modeIndex == modes.Length - <span class="number">1</span>)) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> middleIndex = modeIndex * <span class="number">3</span>;</div><div class="line">	<span class="keyword">int</span> fixedIndex, enforcedIndex;</div><div class="line">	<span class="keyword">if</span> (index &lt;= middleIndex) &#123;</div><div class="line">		fixedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (fixedIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">			fixedIndex = points.Length - <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">		enforcedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (enforcedIndex &gt;= points.Length) &#123;</div><div class="line">			enforcedIndex = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		fixedIndex = middleIndex + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (fixedIndex &gt;= points.Length) &#123;</div><div class="line">			fixedIndex = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		enforcedIndex = middleIndex - <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (enforcedIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">			enforcedIndex = points.Length - <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Vector3 middle = points[middleIndex];</div><div class="line">	Vector3 enforcedTangent = middle - points[fixedIndex];</div><div class="line">	<span class="keyword">if</span> (mode == BezierControlPointMode.Aligned) &#123;</div><div class="line">		enforcedTangent = enforcedTangent.normalized * Vector3.Distance(middle, points[enforcedIndex]);</div><div class="line">	&#125;</div><div class="line">	points[enforcedIndex] = middle + enforcedTangent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>And finally, we also have to take looping into account when adding a curve to the spline. The result might be a tangle, but it will remain a proper loop.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCurve</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Vector3 point = points[points.Length - <span class="number">1</span>];</div><div class="line">	Array.Resize(<span class="keyword">ref</span> points, points.Length + <span class="number">3</span>);</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">3</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">2</span>] = point;</div><div class="line">	point.x += <span class="number">1</span>f;</div><div class="line">	points[points.Length - <span class="number">1</span>] = point;</div><div class="line"></div><div class="line">	Array.Resize(<span class="keyword">ref</span> modes, modes.Length + <span class="number">1</span>);</div><div class="line">	modes[modes.Length - <span class="number">1</span>] = modes[modes.Length - <span class="number">2</span>];</div><div class="line">	EnforceMode(points.Length - <span class="number">4</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (loop) &#123;</div><div class="line">		points[points.Length - <span class="number">1</span>] = points[<span class="number">0</span>];</div><div class="line">		modes[modes.Length - <span class="number">1</span>] = modes[<span class="number">0</span>];</div><div class="line">		EnforceMode(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-spline-loop.png" alt=""><br>A spline loop.</p>
<p>It is great that we have loops, but it is inconvenient that we can no longer see where the spline begins. We can make this obvious by letting BezierSplineInspector always doubling the size of the dot for the first point.<br>Note that in case of a loop the last point will be drawn on top of it, so if you clicked the middle of the big dot you’d select the last point, while if you clicked further from the center you’d get the first point.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ShowPoint</span> (<span class="params"><span class="keyword">int</span> index</span>) </span>&#123;</div><div class="line">	Vector3 point = handleTransform.TransformPoint(spline.GetControlPoint(index));</div><div class="line">	<span class="keyword">float</span> size = HandleUtility.GetHandleSize(point);</div><div class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">		size *= <span class="number">2</span>f;</div><div class="line">	&#125;</div><div class="line">	Handles.color = modeColors[(<span class="keyword">int</span>)spline.GetControlPointMode(index)];</div><div class="line">	<span class="keyword">if</span> (Handles.Button(point, handleRotation, size * handleSize, size * pickSize, Handles.DotCap)) &#123;</div><div class="line">		selectedIndex = index;</div><div class="line">		Repaint();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (selectedIndex == index) &#123;</div><div class="line">		EditorGUI.BeginChangeCheck();</div><div class="line">		point = Handles.DoPositionHandle(point, handleRotation);</div><div class="line">		<span class="keyword">if</span> (EditorGUI.EndChangeCheck()) &#123;</div><div class="line">			Undo.RecordObject(spline, <span class="string">"Move Point"</span>);</div><div class="line">			EditorUtility.SetDirty(spline);</div><div class="line">			spline.SetControlPoint(index, handleTransform.InverseTransformPoint(point));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> point;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-large-begin.png" alt=""><br>We start big.</p>
<h2 id="Using-Splines"><a href="#Using-Splines" class="headerlink" title="Using Splines"></a>Using Splines</h2><p>We have been working with splines for a while now, but we haven’t used them for anything yet. There are uncountable things you can do with splines, for example moving an object alongs its path. Let’s create a SplineWalker component that does just that.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SplineWalker</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> BezierSpline spline;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">float</span> duration;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> progress;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		progress += Time.deltaTime / duration;</div><div class="line">		<span class="keyword">if</span> (progress &gt; <span class="number">1</span>f) &#123;</div><div class="line">			progress = <span class="number">1</span>f;</div><div class="line">		&#125;</div><div class="line">		transform.localPosition = spline.GetPoint(progress);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can create a walker object, assign our spline, set a duration, and watch it move after we enter play mode. I simply used a cube and gave it smaller cubes to resemble eyes, so you can see in what direction it’s looking.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walker.png" alt="walker"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walking.png" alt="walking"><br>Walking the spline.</p>
<p>The walker now walks , but it’s not looking in the direction that it’s going. We can add an option for that.</p>
<blockquote>
<p>How does LookAt work?<br>The Transform.LookAt method has multiple versions. We’re using the one where we give it a position in world space and it rotates itself so its forward direction points at that position. As it’s relative to its own position, we had to add the position to our spline’s direction.<br>Providing one direction is not enough to define a 3D rotation. The method also keeps the upward direction of the transform aligned with the world’s up direction. This means that the walker will try to keep itself upright. You could also provide an alternative up vector.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">bool</span> lookForward;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	progress += Time.deltaTime / duration;</div><div class="line">	<span class="keyword">if</span> (progress &gt; <span class="number">1</span>f) &#123;</div><div class="line">		progress = <span class="number">1</span>f;</div><div class="line">	&#125;</div><div class="line">	Vector3 position = spline.GetPoint(progress);</div><div class="line">	transform.localPosition = position;</div><div class="line">	<span class="keyword">if</span> (lookForward) &#123;</div><div class="line">		transform.LookAt(position + spline.GetDirection(progress));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-looking-forward.png" alt="looking forward"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walking-and-looking.png" alt="walking and looking"><br>Looking where you go.</p>
<p>Another option is to keep looping the splines, instead of walking it just once. While we’re at it, we could also make the walker move back and forth, ping-ponging across the spline. Let’s create an enumeration to select between these modes.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SplineWalkerMode &#123;</div><div class="line">	Once,</div><div class="line">	Loop,</div><div class="line">	PingPong</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now SplineWalker has to remember whether it’s going forward or backward. It also needs to adjust the progress when passing the spline ends depending on its mode.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> SplineWalkerMode mode;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">bool</span> goingForward = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (goingForward) &#123;</div><div class="line">		progress += Time.deltaTime / duration;</div><div class="line">		<span class="keyword">if</span> (progress &gt; <span class="number">1</span>f) &#123;</div><div class="line">			<span class="keyword">if</span> (mode == SplineWalkerMode.Once) &#123;</div><div class="line">				progress = <span class="number">1</span>f;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mode == SplineWalkerMode.Loop</span>) </span>&#123;</div><div class="line">				progress -= <span class="number">1</span>f;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				progress = <span class="number">2</span>f - progress;</div><div class="line">				goingForward = <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		progress -= Time.deltaTime / duration;</div><div class="line">		<span class="keyword">if</span> (progress &lt; <span class="number">0</span>f) &#123;</div><div class="line">			progress = -progress;</div><div class="line">			goingForward = <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Vector3 position = spline.GetPoint(progress);</div><div class="line">	transform.localPosition = position;</div><div class="line">	<span class="keyword">if</span> (lookForward) &#123;</div><div class="line">		transform.LookAt(position + spline.GetDirection(progress));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-walk-mode.png" alt=""><br>Walking in different ways.</p>
<p>Another thing we could do is create a decorator that instantiates a sequence of items along a spline when it awakens. We also give it a forward-looking option, which applies to the items it spawns. The item sequence with some frequency, allowing for repetitions. Of course, if either the frequency is zero or there are no items, we do nothing.<br>We need some items, so create a few prefabs for that purpose as well.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SplineDecorator</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> BezierSpline spline;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> frequency;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">bool</span> lookForward;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Transform[] items;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (frequency &lt;= <span class="number">0</span> || items == <span class="literal">null</span> || items.Length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">float</span> stepSize = <span class="number">1</span>f / (frequency * items.Length);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, f = <span class="number">0</span>; f &lt; frequency; f++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.Length; i++, p++) &#123;</div><div class="line">				Transform item = Instantiate(items[i]) <span class="keyword">as</span> Transform;</div><div class="line">				Vector3 position = spline.GetPoint(p * stepSize);</div><div class="line">				item.transform.localPosition = position;</div><div class="line">				<span class="keyword">if</span> (lookForward) &#123;</div><div class="line">					item.transform.LookAt(position + spline.GetDirection(p * stepSize));</div><div class="line">				&#125;</div><div class="line">				item.transform.parent = transform;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorator.png" alt="decorator and prefabs"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating.png" alt="decorated loop"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating-no-loop.png" alt="decorated non-loop"><br>Decorating splines.</p>
<p>This works well for loops, but it doesn’t go all the way to the end of splines that aren’t loops. We can fix this by increasing our step size to cover the entire length of the spline, as long as it’s not a loop and we have more than one item to place.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (frequency &lt;= <span class="number">0</span> || items == <span class="literal">null</span> || items.Length == <span class="number">0</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">float</span> stepSize = frequency * items.Length;</div><div class="line"><span class="keyword">if</span> (spline.Loop || stepSize == <span class="number">1</span>) &#123;</div><div class="line">	stepSize = <span class="number">1</span>f / stepSize;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	stepSize = <span class="number">1</span>f / (stepSize - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-decorating-non-loop-complete.png" alt=""><br>Going all the way.</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://catlikecoding.com/unity/tutorials/curves-and-splines/" target="_blank" rel="external">Curves and Splines, making your own path</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tospan.me/2017/02/05/Unity/Curves-and-Splines/" data-id="cizhoren3002m1gvwfm2dkdeh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Basics/">Basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/06/Unity/Tutorials-Maze/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Unity Maze
        
      </div>
    </a>
  
  
    <a href="/2017/02/05/Unity/Tutorials-Frames-Per-Second/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Unity FPS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Development/">Game Development</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Programming-Patterns/">Game Programming Patterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity-Tutorials/">Unity Tutorials</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Basics/">Basics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Games/">Games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/">Geometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linear-Algebra/">Linear Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematics/">Mathematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numerical-Analysis/">Numerical Analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Patterns/">Patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scripting/">Scripting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 17.5px;">Algorithms</a> <a href="/tags/Basics/" style="font-size: 12.5px;">Basics</a> <a href="/tags/C/" style="font-size: 12.5px;">C#</a> <a href="/tags/Data-Structure/" style="font-size: 16.25px;">Data Structure</a> <a href="/tags/Games/" style="font-size: 10px;">Games</a> <a href="/tags/Geometry/" style="font-size: 11.25px;">Geometry</a> <a href="/tags/Linear-Algebra/" style="font-size: 13.75px;">Linear Algebra</a> <a href="/tags/Math/" style="font-size: 12.5px;">Math</a> <a href="/tags/Mathematics/" style="font-size: 12.5px;">Mathematics</a> <a href="/tags/Numerical-Analysis/" style="font-size: 10px;">Numerical Analysis</a> <a href="/tags/Patterns/" style="font-size: 15px;">Patterns</a> <a href="/tags/Scripting/" style="font-size: 18.75px;">Scripting</a> <a href="/tags/Unity/" style="font-size: 20px;">Unity</a> <a href="/tags/default/" style="font-size: 11.25px;">default</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/23/Unity-Multiplayer-And-Networking/">Unity Multiplayer And Networking</a>
          </li>
        
          <li>
            <a href="/2017/02/23/Unity-Physics/">Unity Physics</a>
          </li>
        
          <li>
            <a href="/2017/02/10/Game-Development/">游戏开发</a>
          </li>
        
          <li>
            <a href="/2017/02/08/Unity/Scripting-Quick-Benchmark/">Unity 简单基准测试</a>
          </li>
        
          <li>
            <a href="/2017/02/07/Unity/Patterns-FSM/">游戏编程设计模式:有限状态机(FSM)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 To Span<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>