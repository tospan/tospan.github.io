<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Interview C# | 吐司片的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Difference between Class and Structure.结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。　　结构不能声明默认构造函数（没有参数的构造函数）或析构函数。　　结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview C#">
<meta property="og:url" content="http://tospan.me/2017/02/09/Interview-C-Sharp/index.html">
<meta property="og:site_name" content="吐司片的博客">
<meta property="og:description" content="Difference between Class and Structure.结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。　　结构不能声明默认构造函数（没有参数的构造函数）或析构函数。　　结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）">
<meta property="og:updated_time" content="2017-02-09T07:37:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Interview C#">
<meta name="twitter:description" content="Difference between Class and Structure.结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。　　结构不能声明默认构造函数（没有参数的构造函数）或析构函数。　　结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）">
  
    <link rel="alternate" href="/atom.xml" title="吐司片的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">吐司片的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Work hard, play hard.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tospan.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Interview-C-Sharp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/09/Interview-C-Sharp/" class="article-date">
  <time datetime="2017-02-09T07:37:06.000Z" itemprop="datePublished">2017-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/default/">default</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Interview C#
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Difference-between-Class-and-Structure"><a href="#Difference-between-Class-and-Structure" class="headerlink" title="Difference between Class and Structure."></a>Difference between Class and Structure.</h2><p>结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。<br>　　结构不能声明默认构造函数（没有参数的构造函数）或析构函数。<br>　　结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）来实现默认构造函数。<br>　　结构不能从类或其他结构继承。<br>　　结构是值类型 – 如果从结构创建一个对象并将该对象赋给某个变量，变量则包含结构的全部值。复制包含结构的变量时，将复制所有数据，对新副本所做的任何修改都不会改变旧副本的数据。<br>　　由于结构不使用引用，因此结构没有标识 – 具有相同数据的两个值类型实例是无法区分的。C# 中的所有值类型本质上都继承自ValueType，后者继承自 Object。编译器可以在一个称为装箱的过程中将值类型转换为引用类型。</p>
<p>结构具有以下特点：<br>　　结构是值类型，而类是引用类型。<br>　　向方法传递结构时，结构是通过传值方式传递的，而不是作为引用传递的。<br>　　与类不同，结构的实例化可以不使用 new 运算符。<br>　　结构可以声明构造函数，但它们必须带参数。<br>　　一个结构不能从另一个结构或类继承，而且不能作为一个类的基。所有结构都直接继承自 System.ValueType，后者继承自 System.Object。<br>　　结构可以实现接口。<br>　　在结构中初始化实例字段是错误的。</p>
<p>结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）<br>就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。</p>
<h2 id="What-is-Coroutine-is-it-running-on-new-thread"><a href="#What-is-Coroutine-is-it-running-on-new-thread" class="headerlink" title="What is Coroutine,is it running on new thread?"></a>What is Coroutine,is it running on new thread?</h2><h2 id="Difference-between-Stack-and-Heap"><a href="#Difference-between-Stack-and-Heap" class="headerlink" title="Difference between Stack and Heap."></a>Difference between Stack and Heap.</h2><p>  Heap是堆，空间是由手动操作分配和释放的，它的存储区很大的自由存储区。<br>  Stack是栈，是由是操作系统自动分配和释放的，栈上的空间是有限的。程序在编译期间变量和函数分配内存都是在栈上进行的，且在运行时函数调用时的参数的传递也是在栈上进行的。</p>
<ol>
<li>heap是堆，stack是栈。</li>
<li>stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。</li>
<li>stack空间有限，heap的空间是很大的自由区。<br>栈通常保存着我们代码执行的步骤，如在代码段1中 AddFive()方法，int pValue变量，int result变量等等。而堆上存放的则多是对象，数据等。（译者注:忽略编译器优化）我们可以把栈想象成一个接着一个叠放在一起的盒子。当我们使用的时候，每次从最顶部取走一个盒子。栈也是如此，当一个方法（或类型）被调用完成的时候，就从栈顶取走（called a Frame，译注：调用帧），接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。</li>
</ol>
<h2 id="What-do-you-mean-by-Inheritance-Explain-with-example"><a href="#What-do-you-mean-by-Inheritance-Explain-with-example" class="headerlink" title="What do you mean by Inheritance ? Explain with example."></a>What do you mean by Inheritance ? Explain with example.</h2><h2 id="What-do-you-mean-by-Polymorohism-Explain-with-example"><a href="#What-do-you-mean-by-Polymorohism-Explain-with-example" class="headerlink" title="What do you mean by Polymorohism? Explain with example."></a>What do you mean by Polymorohism? Explain with example.</h2><h2 id="What-is-overriding"><a href="#What-is-overriding" class="headerlink" title="What is overriding ?"></a>What is overriding ?</h2><h2 id="What-is-overloading"><a href="#What-is-overloading" class="headerlink" title="What is overloading ?"></a>What is overloading ?</h2><h2 id="Difference-between-overriding-重写-and-overloading-重载"><a href="#Difference-between-overriding-重写-and-overloading-重载" class="headerlink" title="Difference between overriding(重写) and overloading(重载)."></a>Difference between overriding(重写) and overloading(重载).</h2><p>  1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。<br>  2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。<br>  3、覆盖要求参数列表相同；重载要求参数列表不同。<br>  4、覆盖关系中，调用那个方法体，是根据对象的类型（对像对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。<br>  Override是重写的意思，它表示重写基类的方法，而且方法的名称，返回类型，参数类型，参数个数要与基类相同。<br>  Overload是重载是意思，它也表示重写基类的方法，但是只要方法名相同，别的可以不同。</p>
<h2 id="What-is-the-use-of-Virtual-keyword"><a href="#What-is-the-use-of-Virtual-keyword" class="headerlink" title="What is the use of Virtual keyword ?"></a>What is the use of Virtual keyword ?</h2><h2 id="Difference-between-Static-Class-and-Singleton"><a href="#Difference-between-Static-Class-and-Singleton" class="headerlink" title="Difference between Static Class and Singleton."></a>Difference between Static Class and Singleton.</h2><h2 id="What-is-Abstract-Class"><a href="#What-is-Abstract-Class" class="headerlink" title="What is Abstract Class ?"></a>What is Abstract Class ?</h2><h2 id="Difference-between-Abstract-Class-and-interface"><a href="#Difference-between-Abstract-Class-and-interface" class="headerlink" title="Difference between Abstract Class and interface."></a>Difference between Abstract Class and interface.</h2><p>声明方法的存在而不去实现它的类被叫做抽像类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽像类，并让它指向具体子类的一个实例。不能有抽像构造函数或抽像静态方法。Abstract 类的子类为它们父类中的所有抽像方法提供实现，否则它们也是抽像类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>接口（interface）是抽像类的变体。在接口中，所有方法都是抽像的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽像的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对像上调用接口的方法。由于有抽像类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<h2 id="What-is-Serialization-序列化-and-De-Serialization-反序列化"><a href="#What-is-Serialization-序列化-and-De-Serialization-反序列化" class="headerlink" title="What is Serialization(序列化) and De-Serialization(反序列化) ?"></a>What is Serialization(序列化) and De-Serialization(反序列化) ?</h2><p>序列化：序列化是将对象状态转换为可保持或传输的格式的过程，比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象。所有可序列化的类都被标记为[serializable]，与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p>
<h2 id="Does-C-support-multiple-inheritance"><a href="#Does-C-support-multiple-inheritance" class="headerlink" title="Does C# support multiple inheritance ?"></a>Does C# support multiple inheritance ?</h2><h2 id="What-do-you-mean-by-Generic-Function-or-Generic-Class"><a href="#What-do-you-mean-by-Generic-Function-or-Generic-Class" class="headerlink" title="What do you mean by Generic Function or Generic Class ?"></a>What do you mean by Generic Function or Generic Class ?</h2><h2 id="请简述关键字Sealed用在类声明和函数声明时的作用，sealed修饰符有什么特点"><a href="#请简述关键字Sealed用在类声明和函数声明时的作用，sealed修饰符有什么特点" class="headerlink" title="请简述关键字Sealed用在类声明和函数声明时的作用，sealed修饰符有什么特点"></a>请简述关键字Sealed用在类声明和函数声明时的作用，sealed修饰符有什么特点</h2><p>  类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。<br>  sealed 修饰符可以应用于类、实例方法和属性。密封类不能被继承；密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。</p>
<h2 id="请简述面向对象的多态的特性及意义！"><a href="#请简述面向对象的多态的特性及意义！" class="headerlink" title="请简述面向对象的多态的特性及意义！"></a>请简述面向对象的多态的特性及意义！</h2><p>面向对象的编程使用了派生继承以及虚函数机制.一个本来指向基类的对象指针可以指向其派生类的.并访问从基类继承而来的成员变量和函数.而虚函数是专门为这个特性设计的,这个函数在每个基类的派生类中都是同一个名字,但函数体却并不一定相同,派生类往往为实现自己的功能而修改这个虚函数.这样用一个指针就能够实现对多种不同的派生类的访问, 并实现其派生类的特定功能(代码 )</p>
<h2 id="接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？"><a href="#接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？" class="headerlink" title="接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？"></a>接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？</h2><p>接口是可以继承接口的，抽象类是可以实现接口的，抽象类可以继承实体类，但是有个条件，条件是，实体类必须要有明确的构造函数。</p>
<h2 id="C-中的接口和类有什么异同。"><a href="#C-中的接口和类有什么异同。" class="headerlink" title="C#中的接口和类有什么异同。"></a>C#中的接口和类有什么异同。</h2><p>接口,是可以多继承,类只有单继承.接口强调了你必须实现,而没有具本实现的方法和虚类有点相似。</p>
<h2 id="请描述Interface与抽象类之间的不同"><a href="#请描述Interface与抽象类之间的不同" class="headerlink" title="请描述Interface与抽象类之间的不同"></a>请描述Interface与抽象类之间的不同</h2><p>  抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。</p>
<p>  参考<a href="http://www.cnblogs.com/seapub/archive/2012/08/08/2628433.html" target="_blank" rel="external">http://www.cnblogs.com/seapub/archive/2012/08/08/2628433.html</a></p>
<h2 id="Static-Nested-Class-和-Inner-Class的不同，说得越多越好"><a href="#Static-Nested-Class-和-Inner-Class的不同，说得越多越好" class="headerlink" title="Static Nested Class 和 Inner Class的不同，说得越多越好"></a>Static Nested Class 和 Inner Class的不同，说得越多越好</h2><p>StaticNested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<h2 id="C-中-property-与-attribute的区别，他们各有什么用处，这种机制的好处在哪里？"><a href="#C-中-property-与-attribute的区别，他们各有什么用处，这种机制的好处在哪里？" class="headerlink" title="C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？"></a>C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？</h2><p>attribute:自定义属性的基类;property :类中的属性。一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质</p>
<h2 id="C-可否对内存进行直接的操作？"><a href="#C-可否对内存进行直接的操作？" class="headerlink" title="C#可否对内存进行直接的操作？"></a>C#可否对内存进行直接的操作？</h2><p>在.net下，.net引用了垃圾回收（GC）功能，我们不用担心内存漏洞，它替代了程序员不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法。</p>
<h2 id="类成员有-种可访问形式？"><a href="#类成员有-种可访问形式？" class="headerlink" title="类成员有_种可访问形式？"></a>类成员有<strong>_</strong>种可访问形式？</h2><p>this.; newClass().Method;</p>
<h2 id="什么是虚函数？什么是抽像函数？"><a href="#什么是虚函数？什么是抽像函数？" class="headerlink" title="什么是虚函数？什么是抽像函数？"></a>什么是虚函数？什么是抽像函数？</h2><p>虚函数：可由子类继承并重写的函数。抽像函数：规定其非虚子类必须实现的函数，必须被重写。</p>
<h2 id="什么是XML？"><a href="#什么是XML？" class="headerlink" title="什么是XML？"></a>什么是XML？</h2><p>  XML即可扩展标记语言。eXtensible Markup Language.标记是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，即可以选择国际通用的标记语言，比如HTML，也可以使用象XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从SGML中简化修改出来的。它主要用到的有XML、XSL和XPath等。</p>
<h2 id="概述反射"><a href="#概述反射" class="headerlink" title="概述反射"></a>概述反射</h2><p>  反射：公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。
　　</p>
<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>  动态获取程序集信息</p>
<h2 id="反射的实现原理？"><a href="#反射的实现原理？" class="headerlink" title="反射的实现原理？"></a>反射的实现原理？</h2><p>  审查元数据并收集关于它的类型信息的能力。<br>  参考<a href="http://blog.163.com/xuanmingzhiyou@yeah/blog/static/1424776762011612115124188/" target="_blank" rel="external">http://blog.163.com/xuanmingzhiyou@yeah/blog/static/1424776762011612115124188/</a></p>
<p>  反射个人认为，就是得到程序集中的属性和方法。<br>  实现步骤：</p>
<ol>
<li>导入using System.Reflection;</li>
<li>Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly</li>
<li>foreach (Type type in assembly.GetTypes())<pre><code>{
    string t = type.Name;
}
</code></pre>得到程序集中所有类的名称</li>
<li>Type type = assembly.GetType(“程序集.类名”);获取当前类的类型</li>
<li>Activator.CreateInstance(type); 创建此类型实例</li>
<li>MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法</li>
<li>mInfo.Invoke(null,方法参数);</li>
</ol>
<h2 id="用Singleton如何写设计模式"><a href="#用Singleton如何写设计模式" class="headerlink" title="用Singleton如何写设计模式"></a>用Singleton如何写设计模式</h2><p>static属性里面new ,构造函数private</p>
<h2 id="在c-中using和new这两个关键字有什么意义，请写出你所知道的意义？using-指令-和语句-new-创建实例-new-隐藏基类中方法。"><a href="#在c-中using和new这两个关键字有什么意义，请写出你所知道的意义？using-指令-和语句-new-创建实例-new-隐藏基类中方法。" class="headerlink" title="在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using 指令 和语句 new 创建实例 new 隐藏基类中方法。"></a>在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using 指令 和语句 new 创建实例 new 隐藏基类中方法。</h2><p>using 引入名称空间或者使用非托管资源<br>　　new 新建实例或者隐藏父类方法</p>
<h2 id="需要实现对一个字符串的处理-首先将该字符串首尾的空格去掉-如果字符串中间还有连续空格的话-仅保留一个空格-即允许字符串中间有多个空格-但连续的空格数不可超过一个"><a href="#需要实现对一个字符串的处理-首先将该字符串首尾的空格去掉-如果字符串中间还有连续空格的话-仅保留一个空格-即允许字符串中间有多个空格-但连续的空格数不可超过一个" class="headerlink" title="需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个."></a>需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个.</h2><p>string inputStr=” xx xx “;<br>　　inputStr = Regex.Replace(inputStr.Trim(),”*”,” “);</p>
<h2 id="谈谈final-finally-finalize的区别。"><a href="#谈谈final-finally-finalize的区别。" class="headerlink" title="谈谈final,finally, finalize的区别。"></a>谈谈final,finally, finalize的区别。</h2><p>final－修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中 不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final的方法也同样只能使用，不能重载<br>　　finally－再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>　　finalize－方法名。Java 技术允许使用finalize() 方法在垃圾收集器将对像从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的 ，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对像之前对这个对象调用的。</p>
<h2 id="short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h2><p>short s1 =1; s1 = s1 + 1;有错，s1是short型，s1+1是int型,不能显式转化为short型。可修改为s1=(short)(s1 + 1) 。short s1 = 1;s1 += 1正确。</p>
<h2 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</h2><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。<br>　　equals()和==方法决定引用值是否指向同一对像equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="List-Set-Map是否继承自Collection接口"><a href="#List-Set-Map是否继承自Collection接口" class="headerlink" title="List, Set, Map是否继承自Collection接口?"></a>List, Set, Map是否继承自Collection接口?</h2><p>List，Set是Map不是</p>
<h2 id="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?"></a>swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</h2><p>switch（expr1）中，expr1是一个整型，字符或字符串，因此可以作用在byte和long上，也可以作用在string上。</p>
<h2 id="求以下表达式的值，写出您想到的一种或几种实现方法：-1-2-3-4-……-m"><a href="#求以下表达式的值，写出您想到的一种或几种实现方法：-1-2-3-4-……-m" class="headerlink" title="求以下表达式的值，写出您想到的一种或几种实现方法： 1-2+3-4+……+m"></a>求以下表达式的值，写出您想到的一种或几种实现方法： 1-2+3-4+……+m</h2><p>int Num =this.TextBox1.Text.ToString() ;<br>　　int Sum = 0 ;<br>　　for (int i = 0 ; i &lt; Num + 1 ; i++)<br>　　{<br>　　　　if((i%2) == 1)<br>　　　　{<br>　　　　　　Sum += i ;<br>　　　　}<br>　　　　else<br>　　　　{<br>　　　　　　Sum = Sum - i ;<br>　　　　}<br>　　}<br>　　Console.WriteLine(Sum.ToString());<br>　　Console.ReadLine() ;</p>
<h2 id="Const和ReadOnly？"><a href="#Const和ReadOnly？" class="headerlink" title="Const和ReadOnly？"></a>Const和ReadOnly？</h2><p>Const用来申明编程时申明常量，ReadOnly用来申明运行时常量。</p>
<h2 id="UDP和TCP连接有和异同？"><a href="#UDP和TCP连接有和异同？" class="headerlink" title="UDP和TCP连接有和异同？"></a>UDP和TCP连接有和异同？</h2><p>TCP是传输控制协议，提供的是面向连接的，是可靠的，字节流服务，当用户和服务器彼此进行数据交互的时候，必须在他们数据交互前要进行TCP连接之后才能传输数据。TCP提供超时重拨，检验数据功能。UDP是用户数据报协议，是一个简单的面向数据报的传输协议，是不可靠的连接。</p>
<h2 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP/IP协议栈各个层次及分别的功能"></a>TCP/IP协议栈各个层次及分别的功能</h2><p>网络接口层：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收。<br>网络层：处理分组在网络中的活动，例如路由选择和转发等，这一层主要包括IP协议、ARP、ICMP协议等。<br>传输层：主要功能是提供应用程序之间的通信，这一层主要是TCP/UDP协议。<br>应用层：用来处理特定的应用，针对不同的应用提供了不同的协议，例如进行文件传输时用到的FTP协议，发送email用到的SMTP等。</p>
<p>50.进程和线程分别该怎么理解？<br>进程是比线程大的程序运行单元，都是由操作系统所体会的系统运行单元<br>    一个程序中至少要有一个进程，有一个进程中，至少要有一个线程，线程的划分尺度要比进程要小，进程拥有独立的内存单元，线程是共享内存，从而极大的提高了程序的运行效率同一个进程中的多个线程可以并发执行。</p>
<h2 id="能用foreach遍历访问的对象需要实现？"><a href="#能用foreach遍历访问的对象需要实现？" class="headerlink" title="能用foreach遍历访问的对象需要实现？"></a>能用foreach遍历访问的对象需要实现？</h2><p>需要实现IEnumerable接口和GetEnumerator()方法。</p>
<h2 id="Error和Exception有是区别？"><a href="#Error和Exception有是区别？" class="headerlink" title="Error和Exception有是区别？"></a>Error和Exception有是区别？</h2><p>error表示恢复不是不可能，但是很困难，exception表示一种实际或实现问题，它表示程序运行正常不可以发生的。</p>
<h2 id="HashMap和Hashtable区别？"><a href="#HashMap和Hashtable区别？" class="headerlink" title="HashMap和Hashtable区别？"></a>HashMap和Hashtable区别？</h2><p>HashMap是Hashtable的轻量级实现，非线程安全的实现他们都实现了map接口，主要区别是HashMap键值可以为空null,效率可以高于Hashtable。</p>
<h2 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h2><p>Collection是集合类的上级接口，Collections是针对集合类的一个帮助类，它提供一系列静态方法来实现对各种集合的搜索，排序，线程安全化操作。 </p>
<h2 id="数组有没有Length-这和方法？string有没有这个方法？"><a href="#数组有没有Length-这和方法？string有没有这个方法？" class="headerlink" title="数组有没有Length()这和方法？string有没有这个方法？"></a>数组有没有Length()这和方法？string有没有这个方法？</h2><p>数组中没有这个方法，但有这个属性，string中有这个方法。</p>
<h2 id="构造器Constructor是否可以被继承？是否可以被Override"><a href="#构造器Constructor是否可以被继承？是否可以被Override" class="headerlink" title="构造器Constructor是否可以被继承？是否可以被Override?"></a>构造器Constructor是否可以被继承？是否可以被Override?</h2><p>Constructor不可以被继承，因此不能被重写（Overriding），但可以被重载(Overloading).</p>
<h2 id="ref参数和out参数是什么？有什么区别？"><a href="#ref参数和out参数是什么？有什么区别？" class="headerlink" title="ref参数和out参数是什么？有什么区别？"></a>ref参数和out参数是什么？有什么区别？</h2><p>ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。<br>不同点就是输出参数必须对参数进行初始化。<br>ref参数是引用，out参数为输出参数。</p>
<h2 id="String-s-new-String-“xyz”-创建了几个String-Object"><a href="#String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="String s = new String(“xyz”);创建了几个String Object?"></a>String s = new String(“xyz”);创建了几个String Object?</h2><p>两个对象，一个是“xyx”,一个是指向“xyx”的引用对像s。</p>
<h2 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h2><p>因为String类是final类所以不可以继承string类。</p>
<h2 id="C-中，string-str-null-与-string-str-””，请尽量用文字说明区别"><a href="#C-中，string-str-null-与-string-str-””，请尽量用文字说明区别" class="headerlink" title="C#中，string str = null 与 string str =””，请尽量用文字说明区别"></a>C#中，string str = null 与 string str =””，请尽量用文字说明区别</h2><p>string str=””初始化对象分配空间，而stringstr=null初始化对象</p>
<h2 id="C-String类型比stringBuilder类型的优势是什么"><a href="#C-String类型比stringBuilder类型的优势是什么" class="headerlink" title="C# String类型比stringBuilder类型的优势是什么?"></a>C# String类型比stringBuilder类型的优势是什么?</h2><p>  如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而stringBuilder是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用stringBuilder这样比较节约内存。但是string 类的方法和功能仍然还是比stringBuilder类要强。</p>
<p>  string类由于具有不可变性（即对一个string对象进行任何更改时，其实都是创建另外一个string类的对象），所以当需要频繁的对一个string类对象进行更改的时候，建议使用StringBuilder类，StringBuilder类的原理是首先在内存中开辟一定大小的内存空间，当对此StringBuilder类对象进行更改时，如果内存空间大小不够，会对此内存空间进行扩充，而不是重新创建一个对象，这样如果对一个字符串对象进行频繁操作的时候，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。<br>  String主要用于公共API，通用性好、用途广泛、读取性能高、占用内存小。<br>  StringBuilder主要用于拼接String，修改性能好。<br>  不过现在的编译器已经把 String 的 + 操作优化成 StringBuilder 了，所以一般用String就可以了，String是不可变的，所以天然线程同步。StringBuilder可变，非线程同步。<br>  <a href="http://zhidao.baidu.com/question/240364840.html?qbl=relate_question_0&amp;word=String%C0%E0%D0%CD%B1%C8stringBuilder%C0%E0%D0%CD%B5%C4%D3%C5%CA%C6" target="_blank" rel="external">http://zhidao.baidu.com/question/240364840.html?qbl=relate_question_0&amp;word=String%C0%E0%D0%CD%B1%C8stringBuilder%C0%E0%D0%CD%B5%C4%D3%C5%CA%C6</a></p>
<h2 id="简述StringBuilder和String的区别？"><a href="#简述StringBuilder和String的区别？" class="headerlink" title="简述StringBuilder和String的区别？"></a>简述StringBuilder和String的区别？</h2><p>String是字符串常量。<br>StringBuffer是字符串变量 ，线程安全。<br>StringBuilder是字符串变量，线程不安全。<br>String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。<br>StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。</p>
<h2 id="当一个线程进入一个对象的方法后，其它线程是否可以进入该对象的方法？"><a href="#当一个线程进入一个对象的方法后，其它线程是否可以进入该对象的方法？" class="headerlink" title="当一个线程进入一个对象的方法后，其它线程是否可以进入该对象的方法？"></a>当一个线程进入一个对象的方法后，其它线程是否可以进入该对象的方法？</h2><p>不可以，一个对象的方法只能由一个线程访问。</p>
<h2 id="用最有效的方法算出2乘以8等于几？"><a href="#用最有效的方法算出2乘以8等于几？" class="headerlink" title="用最有效的方法算出2乘以8等于几？"></a>用最有效的方法算出2乘以8等于几？</h2><p>2&lt;&lt;3.</p>
<h2 id="new-关键字用法"><a href="#new-关键字用法" class="headerlink" title="new 关键字用法"></a>new 关键字用法</h2><p>(1)new 运算符 用于创建对象和调用构造函数。<br>(2)new 修饰符 用于向基类成员隐藏继承成员。<br>(3)new 约束   用于在泛型声明中约束可能用作类型参数的参数的类型。</p>
<h2 id="什么是装箱和拆箱？什么是重载？"><a href="#什么是装箱和拆箱？什么是重载？" class="headerlink" title="什么是装箱和拆箱？什么是重载？"></a>什么是装箱和拆箱？什么是重载？</h2><p>装箱就是把值类型转成引用类型，拆箱相反把引用转换成值类型。<br>　　重载就是指一个方法名相同,参数个数不相同,返回值可以相同的方法。</p>
<h2 id="如何把一个array复制到arrayist里"><a href="#如何把一个array复制到arrayist里" class="headerlink" title="如何把一个array复制到arrayist里"></a>如何把一个array复制到arrayist里</h2><p>foreach( object arr in array)arrayist.Add(arr);</p>
<h2 id="请简述值类型与引用类型的区别"><a href="#请简述值类型与引用类型的区别" class="headerlink" title="请简述值类型与引用类型的区别"></a>请简述值类型与引用类型的区别</h2><p>  区别：<br>  1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。<br>  2.值类型存取快，引用类型存取慢。<br>  3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。<br>  4.栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放。<br>  5.值类型继承自System.ValueType,引用类型继承自System.Object。<br>  6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。<br>  7.值类型变量直接把变量的值保存在堆栈中，引用类型的变量把实际数据的地址保存在堆栈中。<br>  基于值类型的变量直接包含值。将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对对象的引用，而不复制对象本身。<br>　所有的值类型均隐式派生自 System.ValueType。与引用类型不同，从值类型不可能派生出新的类型。但与引用类型相同的是，结构也可以实现接口。<br>　与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将null 赋给值类型。 每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。<br>　值类型主要由两类组成：结构、枚举； 结构分为以下几类：Numeric（数值）类型、整型、浮点型、decimal、bool、用户定义的结构。<br>　引用类型的变量又称为对象，可存储对实际数据的引用。声明引用类型的关键字：class、interface、delegate、内置引用类型： object、string</p>
<p>  可参考<a href="http://www.cnblogs.com/JimmyZhang/archive/2008/01/31/1059383.html" target="_blank" rel="external">http://www.cnblogs.com/JimmyZhang/archive/2008/01/31/1059383.html</a></p>
<h2 id="C-中所有引用类型的基类是什么"><a href="#C-中所有引用类型的基类是什么" class="headerlink" title="C#中所有引用类型的基类是什么"></a>C#中所有引用类型的基类是什么</h2><p>  引用类型的基类是System.Object 值类型的基类是System.ValueType同时，值类型也隐式继承自System.Object</p>
<h2 id="请简述ArrayList和List的主要区别"><a href="#请简述ArrayList和List的主要区别" class="headerlink" title="请简述ArrayList和List的主要区别"></a>请简述ArrayList和List<int>的主要区别</int></h2><p>  ArrayList存在不安全类型‘（ArrayList会把所有插入其中的数据都当做Object来处理）装箱拆箱的操作（费时）List是接口，ArrayList是一个实现了该接口的类，可以被实例化。</p>
<h2 id="请简述GC（垃圾回收）产生的原因，并描述如何避免？"><a href="#请简述GC（垃圾回收）产生的原因，并描述如何避免？" class="headerlink" title="请简述GC（垃圾回收）产生的原因，并描述如何避免？"></a>请简述GC（垃圾回收）产生的原因，并描述如何避免？</h2><p>  GC回收堆上的内存，避免：<br>  1）减少new产生对象的次数<br>  2）使用公用的对象（静态成员）<br>  3）将String换为StringBuilder</p>
<h2 id="下列代码在运行中会产生几个临时对象？"><a href="#下列代码在运行中会产生几个临时对象？" class="headerlink" title="下列代码在运行中会产生几个临时对象？"></a>下列代码在运行中会产生几个临时对象？</h2>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">string</span> a = <span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">"abc"</span>);</div><div class="line">a = (a.ToUpper() + <span class="string">"123"</span>).Substring(<span class="number">0</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>  其实在C#中第一行是会出错的（Java中倒是可行）。应该这样初始化：<br>  <code>string b = new string(new char[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;});</code></p>
<h2 id="下列代码在运行中会发生什么问题？如何避免？"><a href="#下列代码在运行中会发生什么问题？如何避免？" class="headerlink" title="下列代码在运行中会发生什么问题？如何避免？"></a>下列代码在运行中会发生什么问题？如何避免？</h2>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;<span class="keyword">int</span>&gt; ls = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</div><div class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span> item <span class="keyword">in</span> ls)</div><div class="line">&#123;</div><div class="line">    Console.WriteLine(item * item);</div><div class="line">    ls.Remove(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  会产生运行时错误，因为foreach是只读的。不能一边遍历一边修改。</p>
<h2 id="在类的构造函数前加上static会报什么错-为什么"><a href="#在类的构造函数前加上static会报什么错-为什么" class="headerlink" title="在类的构造函数前加上static会报什么错?为什么?"></a>在类的构造函数前加上static会报什么错?为什么?</h2><p>  构造函数格式为 public+类名如果加上static会报错（静态构造函数不能有访问修饰符）<br>  原因：静态构造函数不允许访问修饰符，也不接受任何参数；<br>  无论创建多少类型的对象，静态构造函数只执行一次；<br>  运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数；<br>  静态构造函数执行先于任何实例级别的构造函数；<br>  显然也就无法使用this和base来调用构造函数。</p>
<h2 id="C-函数Func-string-a-string-b-用Lambda表达式怎么写"><a href="#C-函数Func-string-a-string-b-用Lambda表达式怎么写" class="headerlink" title="C# 函数Func(string a, string b)用Lambda表达式怎么写?"></a>C# 函数Func(string a, string b)用Lambda表达式怎么写?</h2><p>  <a href="https://msdn.microsoft.com/zh-cn/library/bb397687.aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/bb397687.aspx</a></p>
<h2 id="C-中的委托是什么？事件是不是一种委托？"><a href="#C-中的委托是什么？事件是不是一种委托？" class="headerlink" title="C#中的委托是什么？事件是不是一种委托？"></a>C#中的委托是什么？事件是不是一种委托？</h2><p>委托本质上是一种“方法接口”，它相当于C/C++中的函数指针，当然它比函数指针安全，在C#中通常用于事件处理。事件不是委托，不过由于事件的性质决定了处理它的程序逻辑能访问的参数，因此，在C#中处理事件的逻辑都包装为委托。</p>
<h2 id="C-的委托是什么？有何用处？"><a href="#C-的委托是什么？有何用处？" class="headerlink" title="C#的委托是什么？有何用处？"></a>C#的委托是什么？有何用处？</h2><p>委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。<br>用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。</p>
<h2 id="概述c-中代理和事件？"><a href="#概述c-中代理和事件？" class="headerlink" title="概述c#中代理和事件？"></a>概述c#中代理和事件？</h2><p>代理就是用来定义指向方法的引用。<br>C＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器；</p>
<h2 id="C-中的排序方式有哪些？"><a href="#C-中的排序方式有哪些？" class="headerlink" title="C#中的排序方式有哪些？"></a>C#中的排序方式有哪些？</h2><p>选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序</p>
<h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] array= <span class="keyword">new</span> <span class="keyword">int</span> [*] ;</div><div class="line">　　<span class="keyword">int</span> temp = <span class="number">0</span> ;</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.Length - <span class="number">1</span> ;i++)</div><div class="line">　　&#123;</div><div class="line">　　　　<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; array.Length ;j++)</div><div class="line">　　　　&#123;</div><div class="line">　　　　　　<span class="keyword">if</span> (array[j] &lt; array[i])</div><div class="line">　　　　　　&#123;</div><div class="line">　　　　　　　　temp = array[i] ;</div><div class="line">　　　　　　　　array[i] = array[j] ;</div><div class="line">　　　　　　　　array[j] = temp ;</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h2 id="C-中四种访问修饰符是哪些？各有什么区别？"><a href="#C-中四种访问修饰符是哪些？各有什么区别？" class="headerlink" title="C#中四种访问修饰符是哪些？各有什么区别？"></a>C#中四种访问修饰符是哪些？各有什么区别？</h2><p>1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。</p>
<p>属性修饰符：</p>
<ul>
<li>Serializable：按值将对象封送到远程服务器。</li>
<li>STATread：是单线程套间的意思，是一种线程模型。</li>
<li>MATAThread：是多线程套间的意思，也是一种线程模型。</li>
</ul>
<p>存取修饰符：</p>
<ul>
<li>public：存取不受限制。对任何类和成员都公开，无限制访问</li>
<li>private：只有包含该成员的类可以存取。仅对该类公开</li>
<li>internal：只有当前命名空间可以存取。只能在包含该类的程序集中访问该类</li>
<li>protected：只有包含该成员的类以及派生类可以存取。对该类和其派生类公开</li>
<li>protected internal：protected + internal 访问仅限于从包含类派生的当前程序集或类型。</li>
</ul>
<p>类修饰符：</p>
<ul>
<li>abstract：抽象类。指示一个类只能作为其它类的基类。</li>
<li>sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。</li>
</ul>
<p>成员修饰符：</p>
<ul>
<li>abstract：指示该方法或属性没有实现。</li>
<li>sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。</li>
<li>delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。</li>
<li>const：指定该成员的值只读不允许修改。</li>
<li>event：声明一个事件。</li>
<li>extern：指示方法在外部实现。</li>
<li>override：重写。对由基类继承成员的新实现。</li>
<li>readonly：指示一个域只能在声明时以及相同类的内部被赋值。</li>
<li>static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。</li>
<li>virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。</li>
<li>new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。</li>
</ul>
<h2 id="数列1-1-2-3-5-8-13…第n位数是多少-用C-递归算法实现"><a href="#数列1-1-2-3-5-8-13…第n位数是多少-用C-递归算法实现" class="headerlink" title="数列1,1,2,3,5,8,13…第n位数是多少?用C#递归算法实现"></a>数列1,1,2,3,5,8,13…第n位数是多少?用C#递归算法实现</h2><p>  通项公式应该是an = a(n-1) + a(n-2)<br>  a3=2=1+1<br>  a4=3=1+1+1<br>  a5=1+1+1+2<br>  a6=1+1+1+2+3<br>  ………<br>  an=1+1+1+2+3+…+(n-2)+(n-3)=2+(n-2)(n-3)/2 (n&gt;=3) 这是通项公式，至于递归？…</p>
<h2 id="请写出求斐波那契数列任意一位的值得算法"><a href="#请写出求斐波那契数列任意一位的值得算法" class="headerlink" title="请写出求斐波那契数列任意一位的值得算法"></a>请写出求斐波那契数列任意一位的值得算法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fn</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>||n==<span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">checked</span>(Fn(n - <span class="number">1</span>) + Fn(n - <span class="number">2</span>)); <span class="comment">// when n&gt;46 memory will  overflow</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="a-10-b-15，在不用第三方变量的前提下，把a-b的值互换"><a href="#a-10-b-15，在不用第三方变量的前提下，把a-b的值互换" class="headerlink" title="a=10,b=15，在不用第三方变量的前提下，把a,b的值互换"></a>a=10,b=15，在不用第三方变量的前提下，把a,b的值互换</h2><p>a=a+b;b=a-b;a=a-b;</p>
<h2 id="还有变态要求，需要代码最短呢。有两个结果："><a href="#还有变态要求，需要代码最短呢。有两个结果：" class="headerlink" title="还有变态要求，需要代码最短呢。有两个结果："></a>还有变态要求，需要代码最短呢。有两个结果：</h2><p>1) a^=b^(b^=a^b); // 13个字节<br>2) a=b+(b=a)*0; // 11个字节</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tospan.me/2017/02/09/Interview-C-Sharp/" data-id="cizcqkkds0034agvwwdk7716i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/default/">default</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/10/C-Sharp-OOP/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C Sharp OOP
        
      </div>
    </a>
  
  
    <a href="/2017/02/09/Interview-Unity/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Interview 2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Development/">Game Development</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Basics/">Basics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Games/">Games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/">Geometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linear-Algebra/">Linear Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematics/">Mathematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numerical-Analysis/">Numerical Analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Patterns/">Patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scripting/">Scripting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 10px;">Algorithms</a> <a href="/tags/Basics/" style="font-size: 15px;">Basics</a> <a href="/tags/C/" style="font-size: 13.33px;">C#</a> <a href="/tags/Games/" style="font-size: 10px;">Games</a> <a href="/tags/Geometry/" style="font-size: 11.67px;">Geometry</a> <a href="/tags/Linear-Algebra/" style="font-size: 16.67px;">Linear Algebra</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Mathematics/" style="font-size: 15px;">Mathematics</a> <a href="/tags/Numerical-Analysis/" style="font-size: 10px;">Numerical Analysis</a> <a href="/tags/Patterns/" style="font-size: 10px;">Patterns</a> <a href="/tags/Scripting/" style="font-size: 13.33px;">Scripting</a> <a href="/tags/Unity/" style="font-size: 20px;">Unity</a> <a href="/tags/default/" style="font-size: 18.33px;">default</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/16/Algorithms-Data-Structure/">算法:数据结构</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Sorting/">算法：排序</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Test-Bed/">搭建算法测试环境</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Basics/">Algorithms Basics</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms/">Algorithms</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 To Span<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>