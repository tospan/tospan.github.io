<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Unity Maze | 吐司片的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概述Maze, building your own randomized place
In this tutorial we’ll generate a maze with multiple distinct areas and navigate through it. You’ll learn to

fill a 2D rectangle with a maze-generating algo">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Maze">
<meta property="og:url" content="http://tospan.me/2017/02/06/Unity-Maze/index.html">
<meta property="og:site_name" content="吐司片的博客">
<meta property="og:description" content="概述Maze, building your own randomized place
In this tutorial we’ll generate a maze with multiple distinct areas and navigate through it. You’ll learn to

fill a 2D rectangle with a maze-generating algo">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/maze.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-project.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-maze-prefab.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-maze-config.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-cell-prefab.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-configured.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-generated.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-generating.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-delay.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-int-vector.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-maze-size.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-line-of-cells.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-maze-direction.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-short-random-walk.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-backtracking.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-edges.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-edge-prefabs.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-maze-with-edges.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-walls-without-rotation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-walls-rotated.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-complete-maze.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-first-index.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-middle-index.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-random-index.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-last-index.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-painting.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-wall-prefabs.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-maze-wall-prefabs-array.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-maze-with-paintings.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-assets.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-model.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-hinge.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-hierarchy.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-component.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-configured.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-with-doors-incorrect.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-with-doors-correct.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-room-settings-assets.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-room-settings.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-maze-room-script.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-colored-floors.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-wall-reference.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-colored-rooms.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/11-open-rooms.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/11-joined-rooms.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-player-assets.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-player-prefab.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-exploring.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-player-camera.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-player-view.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-main-camera.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-overlay-opaque.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-overlay-transparent.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/14-open-door.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/14-open-door-away.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-much-overdraw.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-little-overdraw.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-looking-at-hidden-room.png">
<meta property="og:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-shown-when-door-open.png">
<meta property="og:updated_time" content="2017-02-06T02:44:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unity Maze">
<meta name="twitter:description" content="概述Maze, building your own randomized place
In this tutorial we’ll generate a maze with multiple distinct areas and navigate through it. You’ll learn to

fill a 2D rectangle with a maze-generating algo">
<meta name="twitter:image" content="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/maze.png">
  
    <link rel="alternate" href="/atom.xml" title="吐司片的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">吐司片的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Work hard, play hard.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tospan.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Unity-Maze" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/06/Unity-Maze/" class="article-date">
  <time datetime="2017-02-06T02:44:58.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Unity Maze
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Maze, building your own randomized place</p>
<p>In this tutorial we’ll generate a maze with multiple distinct areas and navigate through it. You’ll learn to</p>
<ul>
<li>fill a 2D rectangle with a maze-generating algorithm;</li>
<li>visualize the algorithm by using a coroutine;</li>
<li>place walls and doors;</li>
<li>use object inheritance;</li>
<li>use extension methods;</li>
<li>move through the maze;</li>
<li>combine first-person view and an overlay map;</li>
<li>determine visible rooms.</li>
</ul>
<p>You’re assumed to know the basics of the Unity editor and scripting. If you’ve completed the Clock and Fractal tutorials you’re good to go.</p>
<p>This tutorial requires at least Unity 4.5. It won’t work with earlier versions.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/maze.png" alt="Enter a random maze of your own creation."><br><a id="more"></a></p>
<h2 id="Random-Mazes"><a href="#Random-Mazes" class="headerlink" title="Random Mazes"></a>Random Mazes</h2><p>You’ve probably seen quite a few randomly generated mazes, either in digital form or in print. There is a huge variety of maze types, but fundamentally they always boil down to the same thing. A maze is a collection or areas linked together such that you can start anywhere and from there be able to visit every other area. The shape and layout of these areas and how exactly they are connected defines the character of the maze.<br>It’s time to generate our own maze! You can try out the final version of what we’re going to make right here.<br>Try out the Maze<br>Press space to restart the maze generation. Once it’s done, you can navigate the player avatar with the arrow keys or WASD and rotate with QE. You can right-click to go fullscreen.</p>
<h2 id="Game-Flow"><a href="#Game-Flow" class="headerlink" title="Game Flow"></a>Game Flow</h2><p>If we were to make a game, we would first have to generate a maze and then spawn a player avatar that can navigate that maze. Then whenever a new game is started, we have to destroy the current maze, generate a new one, and place the avatar in it again. Let’s create a game manager to take care of this.<br>Create a new project and place a default directional light somewhere out of the way for some basic lighting. Then add a new GameManager C# script. Let’s arrange the assets by type, so put it in a new Scripts folder. Then create a new empty game object named Game Manager and add our new script component to it.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-project.png" alt=""><br>The Basics.</p>
<p>Our GameManager component simply begins the game when its Start method is called. We also let it restart the game whenever the player presses space. To support that, we need to check each update whether the space key has been pressed.</p>
<blockquote>
<p>How does GetKeyDown work?<br>The Input class has a collection of static methods and properties to get information about user input. Its GetKeyDown method returns true in the frame that a physical button has been pressed down by the user. You pass it the code of the key you’re interested in.<br>This method only returns true during the frame that the key became active. The GetKey method will also return true as long as the key stays pressed. The GetKeyUp method will return true in the frame that the buttom was released. Input has similar methods for mouse buttons and configurable input buttons.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		BeginGame();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space)) &#123;</div><div class="line">			RestartGame();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RestartGame</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>To begin a game we need to create a maze. So let’s add a Maze script, then create a new empty game object named Maze and attach the script to it. Turn it into a prefab by dragging it into a new Prefabs folder that we also create to hold it. Once that’s done, get rid of the instance in the hierarchy.</p>
<blockquote>
<p>What’s a prefab?<br>A prefab is a Unity object – or hierarchy of objects – that doesn’t exist in the scene and hasn’t been activated. You use it as a template, creating clones of it and adding those to the scene.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Maze</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-maze-prefab.png" alt=""><br>Maze prefab.</p>
<p>Now we can add a reference to this prefab to GameManager so it can create instances of it. Add a public variable for the prefab reference and a private one to hold the instance. Then we can instantiate a maze in BeginGame and destroy it in RestartGame before we begin a new game.</p>
<blockquote>
<p>What does Instantiate do?<br>Unity’s Object class, which every MonoBehaviour inherits from, contains the static Instantiate method. This method creates a clone of whatever Object instance you pass to it. Optionally, you can supply a new position and rotation for the clone, otherwise it keeps the values of the original.<br>Note that Instantiate returns an Object reference. If you want to do something with the new clone, you have to cast it to its specific type, which in our case is Maze.<br>Typically, this method is used with prefabs, but you can also clone objects that already exist in the scene.</p>
<p>What does as do?<br>The as operator is for casting to a different type. We could have also written (Maze)Instantiate. The big difference is that casting in the latter way could perform custom type conversion and will result in an error when used on an incompatible type. The as operator doesn’t convert anything, it only checks whether the object instance is of the correct type. If so, it passes along the reference, otherwise it will result in null, not an error. As such, it only works with reference types, not value types.</p>
<p>What does Destroy do?<br>Destroy is sort-of the counterpart of Instantiate. Pass it a component or a game object, and it will make sure it gets destroyed. This means that memory will be freed, which might activate the garbage collector at some point.<br>Note that we are destroying mazeInstance.gameObject, because we want the entire game object gone, not just its Maze component.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Maze mazePrefab;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Maze mazeInstance;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RestartGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Destroy(mazeInstance.gameObject);</div><div class="line">	BeginGame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/01-maze-config.png" alt=""><br>Game Manager can now create a maze.</p>
<h2 id="Maze-Fundamentals"><a href="#Maze-Fundamentals" class="headerlink" title="Maze Fundamentals"></a>Maze Fundamentals</h2><p>Right now the game manager already does its job. When entering play mode, a maze instance is created, while pressing space destroys it and makes a new one. Now it’s up to Maze to generate its contents.<br>We are going to create a flat maze by filling a rectangular grid of configurable size. I’ll make it 20 by 20. We’ll store the cells in a 2D array and create a new MazeCell script to represent the cells. We also need a cell prefab to instantiate.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> sizeX, sizeZ;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> MazeCell cellPrefab;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MazeCell[,] cells;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeCell</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>We need a 3D visualization for our cells. Create a new game object named Maze Cell and add the MazeCell component to it. Then create a default quad object, make it a child of the cell and set its rotation to (90,0,0). That gives us a very simple floor tile that fills the cell’s area. Turn the whole thing into a prefab, get rid of the instance, and give Maze a reference to it.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-cell-prefab.png" alt="maze cell"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-configured.png" alt="maze"><br>Maze cell prefab and a configured maze.</p>
<p>We should now add a Generate method to Maze that will take care of constructing the maze contents. We start with creating our 2D array and simply filling the entire grid with new cells by means of a double for-loop. We put the creation of individual cells in its own method. We instantiate a new cell, put it in the array and give it a descriptive name. We also make it a child object of our maze and position it so that the entire grid is centered.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[sizeX, sizeZ];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; sizeX; x++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; sizeZ; z++) &#123;</div><div class="line">			CreateCell(x, z);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span> (<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">	MazeCell newCell = Instantiate(cellPrefab) <span class="keyword">as</span> MazeCell;</div><div class="line">	cells[x, z] = newCell;</div><div class="line">	newCell.name = <span class="string">"Maze Cell "</span> + x + <span class="string">", "</span> + z;</div><div class="line">	newCell.transform.parent = transform;</div><div class="line">	newCell.transform.localPosition = <span class="keyword">new</span> Vector3(x - sizeX * <span class="number">0.5</span>f + <span class="number">0.5</span>f, <span class="number">0</span>f, z - sizeZ * <span class="number">0.5</span>f + <span class="number">0.5</span>f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now let GameManager call Generate and the maze should appear when you enter play mode.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">	mazeInstance.Generate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-generated.png" alt=""><br>20 by 20 maze cells.</p>
<p>We get a full grid of cells, but we can’t immediately see in what order the cells were generated. It would be useful – and even a bit of fun – to slow down the generation process so we could see how it works. We can do this by turning Generate into a coroutine and inserting some delay before each step. I’ll set it to 0.01 seconds, which means generating 20 by 20 cells would take roughly four seconds, assuming your frame rate is high enough.</p>
<blockquote>
<p>How does WaitForSeconds work?<br>The WaitForSeconds object will monitor Unity’s time value and simply keep iterating until the specified amount of seconds have passed. As corountines perform one iteration step per frame, its precision is only as good as the frame rate.<br>Note that we can reuse the WaitForSeconds instance. We don’t need to create a new one every time. Just don’t use it in two coroutines at the same time.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">float</span> generationStepDelay;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[sizeX, sizeZ];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; sizeX; x++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; sizeZ; z++) &#123;</div><div class="line">			<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">			CreateCell(x, z);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We now have to change GameManager so it starts the coroutine properly. Also, it is important to stop the coroutine when the game is restarted, because it might not have finished generating yet. As we only have to worry about one coroutine, we can take care of this by simply calling StopAllCoroutines. So yes, you can press space while a maze is still being generated and it will immediately start generating a new one.</p>
<blockquote>
<p>Where does a coroutine live?<br>A coroutine is attached to the MonoBehaviour object who’s StartCoroutine was called. In our case GameManager starts the coroutine, so it is attached to our game manager instance and lives and dies with it. Maze just provided the iterator. That’s why we need to stop the coroutine when we destroy our maze instance. If we wouldn’t, Unity would complain that our coroutine is accessing a destroyed object.<br>We could have also attached the coroutine to Maze and it would work just fine without us having to manually stop the coroutine. Later on we’ll still have a reason to stop a coroutine manually, though.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">	StartCoroutine(mazeInstance.Generate());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RestartGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	StopAllCoroutines();</div><div class="line">	Destroy(mazeInstance.gameObject);</div><div class="line">	BeginGame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-generating.png" alt="generating"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/02-maze-delay.png" alt="maze"><br>Maze generation with step delay.</p>
<h2 id="Cell-Coordinates-and-Integer-Vectors"><a href="#Cell-Coordinates-and-Integer-Vectors" class="headerlink" title="Cell Coordinates and Integer Vectors"></a>Cell Coordinates and Integer Vectors</h2><p>To generate a real maze, we will be adding cells to our maze in a random way instead of using the double loop that we’re using at this moment. So we will probably be using maze coordinates to figure out where we are at any given step. As we are operating in a 2D space, we need to use two integers. It would be convenient if we could manipulate the coordinates as a single value, like Vector2 but with ints instead of floats. Unfortunately such a structure does not exist, but we can create one ourselves.<br>Let’s add a new IntVector2 script and make it a struct instead of a class. We give it a public x and z integer. That gives us two integers bundled together as a single value. We’ll also add a special constructor method to it, which allows us to define values via new IntVector2(1, 2).</p>
<blockquote>
<p>Why isn’t IntVector2 immutable?<br>Value types like int and float are immutable. This means that you cannot change the values themselves. They have no identity, they represent constant concepts. A 3 is always a 3. Executing 3 + 1 does not change the 3 nor the 1, it produces a new 4.<br>A struct is a custom value type. It is good design to make them immutable as well, because if we did then everything would be ideal. Value types are immutable. Passing them around copies them. They don’t act like objects some of the time.<br>We could make our vector immutable by simply keeping its components private and not adding public functionality to change them.<br>However, Unity’s various vector structs are not immutable. This is often convenient and fast, but also inconsistent. We can do someVector.x = 3, which changes an existing vector. But we cannot do someTransform.localPostion.x = 3, because of various reasons.<br>The Unity developers decided to make vectors mutable value types, and there are good practical reasons to do so. For the sake of consistency, let’s use the same approach for own own vector.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">struct</span> IntVector2 &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> x, z;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">IntVector2</span> (<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.z = z;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-int-vector.png" alt=""><br>We now have an integer vector.</p>
<p>We will most likely be adding these vectors together at some point. We could create a method for that. But it would be even more convenient if we could simply use the + operator. Fortunately, we can do this by creating an operator method, which is how Unity’s vectors support operation as well. So yes, adding two vectors means that you’re calling a method.<br>Let’s add support for the + operator now. You can define the other operators as well, but addition is all we need here.</p>
<blockquote>
<p>Aren’t we changing a here?<br>Yes, we are changing a inside the operator method. We could also make room for a new vector, but why should we? Our IntVector2 is a struct so it’s passed by value. We can mess around with the argument as much as we like, it won’t change the caller’s value at all. We could do this even if we had decided to make IntVector2 immutable, because we’re inside the struct’s defintion and know what we’re doing. Right?</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntVector2 <span class="keyword">operator</span> + (IntVector2 a, IntVector2 b) &#123;</div><div class="line">	a.x += b.x;</div><div class="line">	a.z += b.z;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can use our integer vector type to add coordinates to MazeCell.</p>
<blockquote>
<p>Shouldn’t cell coordinates be fixed?<br>A cell will get its coordinates when it is created and will never change position. So it would be good design if there would be no way for someone to change the coordinates of a cell. But because we make the coordinates public, everyone could change them at any time!<br>We could make the coordinates private and provide an initializer method to set them once. But then we would need to make sure that the initialize method is never called again. But once we’ve done that, anyone could still get to the game object and do lots of destructive stuff. Like remove the cell component, or destroy the entire game object! How could we stop that? We cannot.<br>I’m not saying you shouldn’t protect the coordinates, but pointing out that no matter what design principles you apply, you’re never safe when working with Unity objects. And then there’s reflection. Don’t assume to be safe, make sure programmers behave.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> IntVector2 coordinates;</div></pre></td></tr></table></figure>
<p>And we can adjust Maze so it uses IntVector2 when creating the cells and for its size as well, instead of using two separate integers.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> IntVector2 size;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[size.x, size.z];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size.x; x++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; size.z; z++) &#123;</div><div class="line">			<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">			CreateCell(<span class="keyword">new</span> IntVector2(x, z));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span> (<span class="params">IntVector2 coordinates</span>) </span>&#123;</div><div class="line">	MazeCell newCell = Instantiate(cellPrefab) <span class="keyword">as</span> MazeCell;</div><div class="line">	cells[coordinates.x, coordinates.z] = newCell;</div><div class="line">	newCell.coordinates = coordinates;</div><div class="line">	newCell.name = <span class="string">"Maze Cell "</span> + coordinates.x + <span class="string">", "</span> + coordinates.z;</div><div class="line">	newCell.transform.parent = transform;</div><div class="line">	newCell.transform.localPosition =</div><div class="line">		<span class="keyword">new</span> Vector3(coordinates.x - size.x * <span class="number">0.5</span>f + <span class="number">0.5</span>f, <span class="number">0</span>f, coordinates.z - size.z * <span class="number">0.5</span>f + <span class="number">0.5</span>f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Unfortunately there’s something wrong now. The maze’s size no longer shows up in the inspector. This is because Unity does not save our custom struct. Fortunately, this is easy to solve by adding the Serializable attribute from the System namespace to IntVector2.</p>
<blockquote>
<p>What’s an attribute?<br>An attribute is a means to attach metadata to fields, methods, and types. For example, you can tell Unity how to display a variable in the editor, whether to save or not save data, indicate that a component requires other components, and lots of other stuff.<br>Atributes are added between brackets in front of whatever they’re attached to and can have arguments, like [Nice] int number or [Nice(42)] int number. Multiple attributes are separated by commas, like [Nice, Sweet] int number.</p>
<p>How does serialization work?<br>Serialization is the process of converting a collection of data in memory into a stream of data that can be stored in a persistent state or transmitted over a network. It’s what Unity does when it saves your scene and asset data. Deserialization is its complement, constructing data in memory from a stream.<br>This functionality is part of .NET and you can read more about it on MSDN, though it’s not required.</p>
<p>Can a struct be Serializable?<br>Yes, since Unity 4.5 custom structs can be serialized. Anything saying they can’t be serialized is outdated.<br>So don’t change IntVector2 into a class. If you do, the algorithm will fail unless you make sure you never adjust the values of a coordinate. For example, the plus operator method tweaks one of its arguments, which is fine for structs as they are copied, but not for classes.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[System.Serializable]</div><div class="line"><span class="keyword">public</span> <span class="keyword">struct</span> IntVector2</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/03-maze-size.png" alt=""><br>Maze size as an integer vector.</p>
<h2 id="Random-Cell-Generation"><a href="#Random-Cell-Generation" class="headerlink" title="Random Cell Generation"></a>Random Cell Generation</h2><p>Let’s do away with our double loop that Maze uses to generate a regular pattern of cells. Instead we’ll pick some random coordinates inside the maze and start generating a line of cells from there, until we run out of the maze.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[size.x, size.z];</div><div class="line">	IntVector2 coordinates = RandomCoordinates;</div><div class="line">	<span class="keyword">while</span> (ContainsCoordinates(coordinates)) &#123;</div><div class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">		CreateCell(coordinates);</div><div class="line">		coordinates.z += <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>To make this work we have to also add a RandomCoordinates property to Maze that produces some coordinates inside it, plus a ContainsCoordinates method that checks whether some coordinates fall inside the maze. Let’s make them public as they would be useful for anything that deals with mazes.</p>
<blockquote>
<p>How do properties work?<br>Properties are methods that pretend to be a variable. It’s a form of syntactic sugar. Here is an example property.<br>int X { get { return x; } set { x = value; } }<br>And here is what is basically boils down to.<br>int GetX () { return x; } int SetX (int value) { x = value; }<br>You can leave out the set or the get part, in which case you have a read-only or a write-only property. You can also give get and set difference access modifiers.</p>
<p>What does &amp;&amp; do?<br>The &amp;&amp; operator is used for boolean logic and stands for “and also”. In other words, x &amp;&amp; y is only true if both x and y are true.<br>Note that if x is found to be false, there’s no point in checking y anymore. If y were a method call or property, it won’t be invoked.<br>The companion of &amp;&amp; is the || operator, which stands for “or else”. So x || y is true if at least one of them is. Also, if x is found to be true, then y will not be considered.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> IntVector2 RandomCoordinates &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> IntVector2(Random.Range(<span class="number">0</span>, size.x), Random.Range(<span class="number">0</span>, size.z));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">ContainsCoordinates</span> (<span class="params">IntVector2 coordinate</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> coordinate.x &gt;= <span class="number">0</span> &amp;&amp; coordinate.x &lt; size.x &amp;&amp; coordinate.z &gt;= <span class="number">0</span> &amp;&amp; coordinate.z &lt; size.z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-line-of-cells.png" alt=""><br>A random line of cells along the Z axis.</p>
<p>But we don’t want to walk in a straight line, we want to move in a random direction each step. But what directions are there to choose from? Let’s create a MazeDirection enum type to explicitly define that we have the north, east, south, and west directions. Place it in its own script file.</p>
<blockquote>
<p>What’s an enum?<br>You use enum to define an enumeration type, which is an ordered list of names. A variable of this type can have one of these names as its value. Each of these names corresponds to a number, by default starting at zero. They are useful whenever you need a limited list of named options.<br>Under the hood, enums are simply integers. This means that you can freely convert between an enum type and int, which we will use quite a bit. You could also declare them to be of a handfull of other types, but we stick to using integers.<br>Just to be sure, enum has nothing to do with enumerators or iterators.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MazeDirection &#123;</div><div class="line">	North,</div><div class="line">	East,</div><div class="line">	South,</div><div class="line">	West</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-maze-direction.png" alt=""><br>Getting a sense of direction.</p>
<p>Now it would be handy if we could ask for a random direction. Unfortunately an enum is not a class or a struct, so we cannot define methods or properties inside it. What we could do is add another static class and put a random property there. Let’s use the plural version as its name and place it in the same file as MazeDirection. We also add a Count constant so we have an official way to know how many directions there are.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MazeDirections</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> Count = <span class="number">4</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> MazeDirection RandomValue &#123;</div><div class="line">		<span class="keyword">get</span> &#123;</div><div class="line">			<span class="keyword">return</span> (MazeDirection)Random.Range(<span class="number">0</span>, Count);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can get a random direction, but how do we adjust the current coordinates based on that? It would be convenient if we could convert a direction into an integer vector somehow. Let’s add a method to MazeDirections to take care of that. We’ll use a private static array of vectors to make this conversion easy.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> IntVector2[] vectors = &#123;</div><div class="line">	<span class="keyword">new</span> IntVector2(<span class="number">0</span>, <span class="number">1</span>),</div><div class="line">	<span class="keyword">new</span> IntVector2(<span class="number">1</span>, <span class="number">0</span>),</div><div class="line">	<span class="keyword">new</span> IntVector2(<span class="number">0</span>, <span class="number">-1</span>),</div><div class="line">	<span class="keyword">new</span> IntVector2(<span class="number">-1</span>, <span class="number">0</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntVector2 <span class="title">ToIntVector2</span> (<span class="params">MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> vectors[(<span class="keyword">int</span>)direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This allows us to convert an arbitrary direction into an integer vector via MazeDirections.ToIntVector2(someDirection). While this works, it looks aweful. It would’ve been convenient if we could do it via someDirection.ToIntVector2() instead. The good news is that we can achieve this by using an extension method. With just a slight change to ToIntVector2 it will behave as if it were an instance method of MazeDirection.</p>
<blockquote>
<p>What’s an extension method?<br>An extension method is a static method inside a static class that behaves like an instance method of some type. That type could be anything, a class, an interface, a struct, a primitive value, or an enum. The first argument of an extension method needs to have the this keyword and defines the type and instance value that the method will operate on.<br>Does this allow us to add methods to everything? Yes, just like you could write any static method that has any type as its argument. Is this a good idea? When used in moderation, it can be. It’s a specialized tool that has its uses, but wielded it with abandon will result in an unstructured mess.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntVector2 <span class="title">ToIntVector2</span> (<span class="params"><span class="keyword">this</span> MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> vectors[(<span class="keyword">int</span>)direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>With these additions it is now easy to have Maze generate a new cell in a random direction each step. We do have to guard against visiting a cell more than once, so let’s add a convenient method to retrieve the maze’s cell at some coordinates.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MazeCell <span class="title">GetCell</span> (<span class="params">IntVector2 coordinates</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> cells[coordinates.x, coordinates.z];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[size.x, size.z];</div><div class="line">	IntVector2 coordinates = RandomCoordinates;</div><div class="line">	<span class="keyword">while</span> (ContainsCoordinates(coordinates) &amp;&amp; GetCell(coordinates) == <span class="literal">null</span>) &#123;</div><div class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">		CreateCell(coordinates);</div><div class="line">		coordinates += MazeDirections.RandomValue.ToIntVector2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/04-short-random-walk.png" alt=""><br>A short random walk.</p>
<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>As you will see when entering play mode and pressing space a few times, only a few cells get generated each time. This happens because it is likely that we bump into an already filled cell. One way to improve our approach is to keep track of a list of active cells. Each time we create a cell, we add it to this list. Then the next generation step we try to move one random step from the last cell in this list. If we cannot do this move, instead of immediately stopping, we remove the current cell from the active list. This way we will do a step backward and try again each time we fail, until the list is empty.<br>We’re going to use a list of maze cells, so start by adding the Systems.Collections.Generic namespace to those used by Maze.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Maze</span> : <span class="title">MonoBehaviour</span></div></pre></td></tr></table></figure>
<p>Then we create a temporary list inside the Generate method. To keep the method simple, let’s put the generation steps in their own methods and supply the active list to them as an argument.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[size.x, size.z];</div><div class="line">	List&lt;MazeCell&gt; activeCells = <span class="keyword">new</span> List&lt;MazeCell&gt;();</div><div class="line">	DoFirstGenerationStep(activeCells);</div><div class="line">	<span class="keyword">while</span> (activeCells.Count &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">		DoNextGenerationStep(activeCells);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The DoFirstGenerationStep method is very short right now. The DoNextGenerationStep is a bit longer, because it has to retrieve the current cell, check whether the move is possible, and take care of removing cells from the list.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoFirstGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	activeCells.Add(CreateCell(RandomCoordinates));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoNextGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> currentIndex = activeCells.Count - <span class="number">1</span>;</div><div class="line">	MazeCell currentCell = activeCells[currentIndex];</div><div class="line">	MazeDirection direction = MazeDirections.RandomValue;</div><div class="line">	IntVector2 coordinates = currentCell.coordinates + direction.ToIntVector2();</div><div class="line">	<span class="keyword">if</span> (ContainsCoordinates(coordinates) &amp;&amp; GetCell(coordinates) == <span class="literal">null</span>) &#123;</div><div class="line">		activeCells.Add(CreateCell(coordinates));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		activeCells.RemoveAt(currentIndex);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>One additional change needed to make this work is to let CreateCell return the new cell that it creates.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MazeCell <span class="title">CreateCell</span> (<span class="params">IntVector2 coordinates</span>) </span>&#123;</div><div class="line">	MazeCell newCell = Instantiate(cellPrefab) <span class="keyword">as</span> MazeCell;</div><div class="line">	cells[coordinates.x, coordinates.z] = newCell;</div><div class="line">	newCell.coordinates = coordinates;</div><div class="line">	newCell.name = <span class="string">"Maze Cell "</span> + coordinates.x + <span class="string">", "</span> + coordinates.z;</div><div class="line">	newCell.transform.parent = transform;</div><div class="line">	newCell.transform.localPosition =</div><div class="line">		<span class="keyword">new</span> Vector3(coordinates.x - size.x * <span class="number">0.5</span>f + <span class="number">0.5</span>f, <span class="number">0</span>f, coordinates.z - size.z * <span class="number">0.5</span>f + <span class="number">0.5</span>f);</div><div class="line">	<span class="keyword">return</span> newCell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/05-backtracking.png" alt=""><br>A larger walk with backtracking.</p>
<h2 id="Connecting-the-Cells"><a href="#Connecting-the-Cells" class="headerlink" title="Connecting the Cells"></a>Connecting the Cells</h2><p>While we now tend to generate longer paths of cells, it’s still far from a complete maze. We should really be smart about how we move from cell to cell.<br>It’s time to keep track of the connections between cells. Each cell has four edges, each of which connects to a neighboring cell, unless it would lead outside of the maze. We could either create a a single bidirectional edge between two cells, or give each their own unidirectional edge. We choose the latter approach, because it is more flexible.<br>Add a script for the new MazeCellEdge component type. Give it a reference to the cell it belongs to and one to the other cell that it connects with. Also give it a direction so we remember its orientation.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeCellEdge</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> MazeCell cell, otherCell;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> MazeDirection direction;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We want to make the edges children of their cells and place them in the same location. Also, once an edge is created its cell should know about it as well. Let’s create an Initialize method to take care of this.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.cell = cell;</div><div class="line">	<span class="keyword">this</span>.otherCell = otherCell;</div><div class="line">	<span class="keyword">this</span>.direction = direction;</div><div class="line">	cell.SetEdge(direction, <span class="keyword">this</span>);</div><div class="line">	transform.parent = cell.transform;</div><div class="line">	transform.localPosition = Vector3.zero;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we need to add a SetEdge method to MazeCell. Let’s add a GetEdge method as well, because that is bound to be useful later. Our cells will store their edges in an array, but no one else needs to know how that works, so we make it private.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> MazeCellEdge[] edges = <span class="keyword">new</span> MazeCellEdge[MazeDirections.Count];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> MazeCellEdge <span class="title">GetEdge</span> (<span class="params">MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> edges[(<span class="keyword">int</span>)direction];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEdge</span> (<span class="params">MazeDirection direction, MazeCellEdge edge</span>) </span>&#123;</div><div class="line">	edges[(<span class="keyword">int</span>)direction] = edge;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Whenever we move from one cell to a new one, we should tell both cells that the edges that connect them are now passages. Whenever we move out of the maze or bump into an already created cell, the edges should become walls instead of passages. So we really have two types of cell edges. Let’s add a MazePassage and a MazeWall component that both extend MazeCellEdge and place them in their own files. Because we only want to use these types and never create an instance of the generic MazeCellEdge, we mark it as abstract.</p>
<blockquote>
<p>What does it mean to be abstract?<br>When a class is abstract it does not allow objects instances of itself to be created. By itself that would be rather useless, but this does not prevent subclasses of itself to be instantiated. Basically, it acts like a foundation, to be extended by other classes but not usable on its own.<br>Abstract classes can have abstract methods as well. These are methods without a body. This enforces that all subclasses will have to provide their own implementation of that method, unless they are abstract as well.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MazeCellEdge</span> : <span class="title">MonoBehaviour</span></div></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazePassage</span> : <span class="title">MazeCellEdge</span> &#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeWall</span> : <span class="title">MazeCellEdge</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-edges.png" alt=""><br>Three new edgy scripts.</p>
<p>Now we can create a prefab for the passage. It’s simply an empty game object with a MazePassage component added to it. A wall prefab can be created the same way, except that we also give it a default cube as a child. This cube is our wall’s 3D representation. Let’s make it 0.05 units thick and position it so that it will end up flush with the north edge of a cell.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-edge-prefabs.png" alt=""><br>Two new prefabs, showing the wall’s cube.</p>
<p>With the prefabs ready, Maze can now get a reference to both, so it can generate instances of them.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazePassage passagePrefab;</div><div class="line"><span class="keyword">public</span> MazeWall wallPrefab;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-maze-with-edges.png" alt=""><br>Maze with edge prefab references.</p>
<p>Now we can create passages and walls in DoNextGenerationStep. Let’s assume we have convenient methods for that. When we would go out of the maze, we add a wall. If we’re still inside the maze, we need to check if the current cell’s neightbor doesn’t exist yet. If so, we create it and place a passage in between them. But if the neighbor already exists, we separate them with a wall.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoNextGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> currentIndex = activeCells.Count - <span class="number">1</span>;</div><div class="line">	MazeCell currentCell = activeCells[currentIndex];</div><div class="line">	MazeDirection direction = MazeDirections.RandomValue;</div><div class="line">	IntVector2 coordinates = currentCell.coordinates + direction.ToIntVector2();</div><div class="line">	<span class="keyword">if</span> (ContainsCoordinates(coordinates)) &#123;</div><div class="line">		MazeCell neighbor = GetCell(coordinates);</div><div class="line">		<span class="keyword">if</span> (neighbor == <span class="literal">null</span>) &#123;</div><div class="line">			neighbor = CreateCell(coordinates);</div><div class="line">			CreatePassage(currentCell, neighbor, direction);</div><div class="line">			activeCells.Add(neighbor);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			CreateWall(currentCell, neighbor, direction);</div><div class="line">			activeCells.RemoveAt(currentIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		CreateWall(currentCell, <span class="literal">null</span>, direction);</div><div class="line">		activeCells.RemoveAt(currentIndex);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The CreatePassage and CreateWall methods simply instantiate their respective prefabs and initialize them, once for both cells. The only real difference between them is that CreateWall’s second cell won’t exist at the edge of the maze.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreatePassage</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazePassage passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(cell, otherCell, direction);</div><div class="line">	passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateWall</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazeWall wall = Instantiate(wallPrefab) <span class="keyword">as</span> MazeWall;</div><div class="line">	wall.Initialize(cell, otherCell, direction);</div><div class="line">	<span class="keyword">if</span> (otherCell != <span class="literal">null</span>) &#123;</div><div class="line">		wall = Instantiate(wallPrefab) <span class="keyword">as</span> MazeWall;</div><div class="line">		wall.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The code above makes use of a convenient GetOpposite method that doesn’t exist yet, so let’s quickly add it to MazeDirections.<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> MazeDirection[] opposites = &#123;</div><div class="line">	MazeDirection.South,</div><div class="line">	MazeDirection.West,</div><div class="line">	MazeDirection.North,</div><div class="line">	MazeDirection.East</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MazeDirection <span class="title">GetOpposite</span> (<span class="params"><span class="keyword">this</span> MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> opposites[(<span class="keyword">int</span>)direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-walls-without-rotation.png" alt=""><br>Walls without rotation.</p>
<p>We have now added some invisible passages and visible walls to the maze. So we can see that the walls are always on the north side of cells, which is incorrect. We fix this by rotating in the right direction in MazeCellEdge’s Initialize method.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.cell = cell;</div><div class="line">	<span class="keyword">this</span>.otherCell = otherCell;</div><div class="line">	<span class="keyword">this</span>.direction = direction;</div><div class="line">	cell.SetEdge(direction, <span class="keyword">this</span>);</div><div class="line">	transform.parent = cell.transform;</div><div class="line">	transform.localPosition = Vector3.zero;</div><div class="line">	transform.localRotation = direction.ToRotation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>And yes, this means we’re going to add yet another convenient method to MazeDirections.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Quaternion[] rotations = &#123;</div><div class="line">	Quaternion.identity,</div><div class="line">	Quaternion.Euler(<span class="number">0</span>f, <span class="number">90</span>f, <span class="number">0</span>f),</div><div class="line">	Quaternion.Euler(<span class="number">0</span>f, <span class="number">180</span>f, <span class="number">0</span>f),</div><div class="line">	Quaternion.Euler(<span class="number">0</span>f, <span class="number">270</span>f, <span class="number">0</span>f)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">ToRotation</span> (<span class="params"><span class="keyword">this</span> MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> rotations[(<span class="keyword">int</span>)direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/06-walls-rotated.png" alt=""><br>Walls with rotation.</p>
<h2 id="Generating-the-Entire-Maze"><a href="#Generating-the-Entire-Maze" class="headerlink" title="Generating the Entire Maze"></a>Generating the Entire Maze</h2><p>While the walls are now correctly rotated, we still don’t fill the entire maze. Even worse, we’re also generating completely walled-off sections, making them unreachable from anywhere else in the maze. This can happen because we choose a completely random direction each step, which could lead to us placing a wall where a passage had already been defined.<br>To completely fill the maze, we should only remove a cell from the active list when all its edges have been initialized. This is the first thing we should check for in DoNextGenerationStep, because a cell in the active list will have become fully initialized when all its neighbors have been visited. And to prevent placing incorrect walls, we should only pick a random direction that is not yet initialized for the current cell.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoNextGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> currentIndex = activeCells.Count - <span class="number">1</span>;</div><div class="line">	MazeCell currentCell = activeCells[currentIndex];</div><div class="line">	<span class="keyword">if</span> (currentCell.IsFullyInitialized) &#123;</div><div class="line">		activeCells.RemoveAt(currentIndex);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	MazeDirection direction = currentCell.RandomUninitializedDirection;</div><div class="line">	IntVector2 coordinates = currentCell.coordinates + direction.ToIntVector2();</div><div class="line">	<span class="keyword">if</span> (ContainsCoordinates(coordinates)) &#123;</div><div class="line">		MazeCell neighbor = GetCell(coordinates);</div><div class="line">		<span class="keyword">if</span> (neighbor == <span class="literal">null</span>) &#123;</div><div class="line">			neighbor = CreateCell(coordinates);</div><div class="line">			CreatePassage(currentCell, neighbor, direction);</div><div class="line">			activeCells.Add(neighbor);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			CreateWall(currentCell, neighbor, direction);</div><div class="line">			<span class="comment">// No longer remove the cell here.</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		CreateWall(currentCell, <span class="literal">null</span>, direction);</div><div class="line">		<span class="comment">// No longer remove the cell here.</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We can easily check whether a cell is fully initialized by having MazeCell keep track of how often an edge has been set.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> initializedEdgeCount;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">bool</span> IsFullyInitialized &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> initializedEdgeCount == MazeDirections.Count;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEdge</span> (<span class="params">MazeDirection direction, MazeCellEdge edge</span>) </span>&#123;</div><div class="line">	edges[(<span class="keyword">int</span>)direction] = edge;</div><div class="line">	initializedEdgeCount += <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>To get an unbiased random uninitialized direction is a little less straightforward. One way is to randomly decide how many uninitialized directions we should skip. Then we loop through our edges array and whenever we find a hole we check whether we are out of skips. If so, this is our direction. Otherwise, we decrease our amount of skips by one.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazeDirection RandomUninitializedDirection &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">int</span> skips = Random.Range(<span class="number">0</span>, MazeDirections.Count - initializedEdgeCount);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MazeDirections.Count; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (edges[i] == <span class="literal">null</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (skips == <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">return</span> (MazeDirection)i;</div><div class="line">				&#125;</div><div class="line">				skips -= <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This will work as long as there are uninitialized edges remaining, otherwise we shouldn’t call this method. If we did, we would run through the loop without returning and won’t have any result. In fact, the compiler will complain that not all code paths return a value. We solve this by throwing an InvalidOperationException at the end of the method, which is the most appropriate exception for this case. This will result in a useful error message in Unity’s console if we make a mistake somewhere and call this method when we shouldn’t.</p>
<blockquote>
<p>What does throw do?<br>The throw keyword works like return, except that it passes along something throwable – an error or exception – instead of the appropriate return type. When something is thrown, invocations will fail upward until it is caught somewhere, which usually result in an error message. In case of a mobila app that’s optimized with Fast but no Exceptions, it will cause a crash.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazeDirection RandomUninitializedDirection &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">int</span> skips = Random.Range(<span class="number">0</span>, MazeDirections.Count - initializedEdgeCount);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MazeDirections.Count; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (edges[i] == <span class="literal">null</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (skips == <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">return</span> (MazeDirection)i;</div><div class="line">				&#125;</div><div class="line">				skips -= <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">"MazeCell has no uninitialized directions left."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-complete-maze.png" alt=""><br>A complete maze.</p>
<p>Finally, we can generate a complete maze! We are now using one flavor of the Growing Tree algorithm. In case you’re curious, you can change the nature of the maze you generate by using a different method to select the current index in DoNextGenerationStep. I have chosen to always select the last index, which causes the algorithm to dive into narrow paths that run all over the maze. Always selecting the first or the middle index will produce very different behavior. Another option is to just pick a random index. Or to choose between two approaches each step. You could even make this configurable if you like, see the Graphs tutorial for a way to do that.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-first-index.png" alt="first"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-middle-index.png" alt="middle"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-random-index.png" alt="random"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/07-last-index.png" alt="last"><br>Comparing first, middle, random, and last index approaches.</p>
<h2 id="Decorating-the-Maze"><a href="#Decorating-the-Maze" class="headerlink" title="Decorating the Maze"></a>Decorating the Maze</h2><p>Our maze looks rather dull. Let’s add some variety by introducing different wall sections. We can do this by hanging some very simple paintings on the walls.<br>First, create a few materials for the paintings, just to add some color variety. Put them together in a new Materials folder and give them any color you like. Next, drag the wall prefab into the scene and name it Wall with Painting 1. Add a new default cube named Painting to this instance. Give the cube a material, then scale and position it so it looks like it’s hanging on the wall. Then turn the whole thing into a new prefab. Repeat this until you have enough paintings. I made three.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-painting.png" alt="materials and prefabs"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-wall-prefabs.png" alt="materials and prefabs"></p>
<p>Walls with paintings.</p>
<p>Now change Maze so it has an array of wall prefabs instead of a single one. Then we can pick one at random from the array whenever we need to instantiate a new wall.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazeWall[] wallPrefabs;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateWall</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazeWall wall = Instantiate(wallPrefabs[Random.Range(<span class="number">0</span>, wallPrefabs.Length)]) <span class="keyword">as</span> MazeWall;</div><div class="line">	wall.Initialize(cell, otherCell, direction);</div><div class="line">	<span class="keyword">if</span> (otherCell != <span class="literal">null</span>) &#123;</div><div class="line">		wall = Instantiate(wallPrefabs[Random.Range(<span class="number">0</span>, wallPrefabs.Length)]) <span class="keyword">as</span> MazeWall;</div><div class="line">		wall.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Then you can add all your wall prefabs to the array of the maze prefab. I added the empty wall multiple times, so it is more likely to be picked. Otherwise the maze will be brimming with paintings.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-maze-wall-prefabs-array.png" alt="wall prefab array"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/08-maze-with-paintings.png" alt="maze with paintings"><br>Making an artsy maze.</p>
<h2 id="Placing-Doors"><a href="#Placing-Doors" class="headerlink" title="Placing Doors"></a>Placing Doors</h2><p>Doors are another interesting element to add to our maze. Let’s add a MazeDoor component that extends MazePassage. Because it will have a rotating part, add a public Transform variable to it named hinge.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeDoor</span> : <span class="title">MazePassage</span> &#123;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Transform hinge;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We will build a door frame from four cubes and put another cube in it with a new Door material, plus a door handle on the right side of it. To allow the door to rotate properly, add an empty game object named Hinge on the left side of the door with a Z-position of 0.5. Make the door and handle objects children of it. Add the MazeDoor component to the root object and connect its hinge, then turn it into a prefab.</p>
<blockquote>
<p>Where are the prefab hinge’s children?<br>Unfortunately, Unity only shows the direct children of a prefab asset root. Even though they aren’t shown, the children do exist. The prefab’s preview shows their 3D models, and they will be visible in any instance added to the scene. You can edit the invisible parts by dragging the prefab into the scene, making changes to the instance, and applying it back to the prefab. This approach will be necessary until Unity fully supports nested prefabs.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-assets.png" alt="door assets"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-model.png" alt="door model"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-hinge.png" alt="door hinge"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-hierarchy.png" alt="door hierarchy"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-door-component.png" alt="door component"><br>Creating a door.</p>
<p>Maze can now get a reference to the door prefab. We want to spawns doors instead of passages some of the time, but really not that often because otherwise the maze will get flooded with doors. So let’s add a doorProbabilty configuration option and use that to decide whether we place a door or a passage. I set it to 0.1, which means that one out of ten passage will become a door.</p>
<blockquote>
<p>What does the question mark do?<br>The question mark, combined with a colon, is a short version of an if-else statement. For example, you could write a full if-else block.<br>int y; if(x &gt; 1) { y = 10; } else { y = 20; }<br>But you can also use this condensed syntax.<br>int y = x &gt; 1 ? 10 : 20;</p>
<p>What does Range do?<br>The Range attribute tells the Unity editor to use a slider to display an int or float variable. Its arguments determine the minimum and maximum values allowed by the slider.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazeDoor doorPrefab;</div><div class="line"></div><div class="line">[Range(<span class="number">0</span>f, <span class="number">1</span>f)]</div><div class="line"><span class="keyword">public</span> <span class="keyword">float</span> doorProbability;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreatePassage</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazePassage prefab = Random.<span class="keyword">value</span> &lt; doorProbability ? doorPrefab : passagePrefab;</div><div class="line">	MazePassage passage = Instantiate(prefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(cell, otherCell, direction);</div><div class="line">	passage = Instantiate(prefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-configured.png" alt="maze configured"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-with-doors-incorrect.png" alt="maze with doors"><br>Doors added to the maze.</p>
<p>We now get doors, but there is something wrong. All the doors are have their handle on the right side, even opposite sides of the same door! We need to make sure that the other side of a door swivels in the opposite direction.<br>We know that the sides of a door are created one after the other. If a door could somehow know that it was created second, it can then mirror itself. What we could do is add a convenient private property to MazeDoor that somehow gives us the opposite side of the door. Then we can mirror and reposition our hinge if the other side already exists. We add this functionality to Initialize by overriding that method with out own version. Inside it, we first call the original version and then do the additional work.</p>
<blockquote>
<p>What’s base?<br>The base keyword is a reference to the object instance itself, just like the this keyword. The important difference is that it also represents the base type that the class extends. This allows you to access functionality that you override. A typical use case is to override a method by first calling the base method and then adding your own stuff, which is exactly what we do here. Had we omitted the keyword, we would’ve created an infinite recursion and the method would keep invoking itself until we got a stack overflow exception.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> MazeDoor OtherSideOfDoor &#123;</div><div class="line">	<span class="keyword">get</span> &#123;</div><div class="line">		<span class="keyword">return</span> otherCell.GetEdge(direction.GetOpposite()) <span class="keyword">as</span> MazeDoor;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell primary, MazeCell other, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">base</span>.Initialize(primary, other, direction);</div><div class="line">	<span class="keyword">if</span> (OtherSideOfDoor != <span class="literal">null</span>) &#123;</div><div class="line">		hinge.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>f, <span class="number">1</span>f, <span class="number">1</span>f);</div><div class="line">		Vector3 p = hinge.localPosition;</div><div class="line">		p.x = -p.x;</div><div class="line">		hinge.localPosition = p;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>However, we can’t just override any method of the class that we’re extending. The original class must have declared that this is possible by marking the method as virtual. So we add the virtual keyword to the Initialize method of MazeCellEdge.</p>
<blockquote>
<p>Why is virtual needed?<br>Not marking a method as virtual is useful for preventing subclasses from overriding your own implementation. But the technical reason is because there’s an important difference between a non-virtual and a virtual method. Looking at it from a very low level, a method call requires a jump to some place where the instructions for that method are stored. If this method were always the same, the jump will always be to the same place. Easy. But when a method can be overridden by a subclass, where we need to jump depends on the type of the object it’s being invoked on. This problem is solved by looking up the method’s location in a table. This table is known as a virtual method table, hence the name of the keyword. If you didn’t know about that table, overridable would probably make more sense.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.cell = cell;</div><div class="line">	<span class="keyword">this</span>.otherCell = otherCell;</div><div class="line">	<span class="keyword">this</span>.direction = direction;</div><div class="line">	cell.SetEdge(direction, <span class="keyword">this</span>);</div><div class="line">	transform.parent = cell.transform;</div><div class="line">	transform.localPosition = Vector3.zero;</div><div class="line">	transform.localRotation = direction.ToRotation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/09-maze-with-doors-correct.png" alt=""><br>Now with correct doors.</p>
<h2 id="Adding-Rooms"><a href="#Adding-Rooms" class="headerlink" title="Adding Rooms"></a>Adding Rooms</h2><p>Our maze is uniformly white and that is rather boring. Let’s spice things up by breaking the maze into rooms of different types. Then we can adjust the appearance of each room based on its type.<br>Create a new serialized MazeRoomSettings class with a public material references for floors and walls.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System;</div><div class="line"></div><div class="line">[Serializable]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeRoomSettings</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Material floorMaterial, wallMaterial;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can give Maze an array of these settings, defining the available room types. Then create a few materials with varying colors and populate the array. Four room types is a good amount for a 20 by 20 maze.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MazeRoomSettings[] roomSettings;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-room-settings-assets.png" alt=""><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-room-settings.png" alt=""><br>Room settings.</p>
<p>Now we are also going to add a MazeRoom class so we can easily keep track of which cell belongs to which room. For now it simply is a wrapper for a list of cells, and it also has a reference to its settings and settings index. We have it extend ScriptableObject so Unity will keep the references intact if we were to cause a recompile while in play mode.</p>
<blockquote>
<p>What’s a ScriptableObject?<br>You typically extend ScriptableObject when creating your own asset type, because Unity can store these objects just like game objects and components. An additional benefit is that such objects are correctly stored and retrieved when scripts are recompiled while Unity is in play mode. This means we could tweaks scripts while walking around a maze and our rooms will be preserved.<br>Couldn’t we just add the Serializable attribute to MazeRoom? No, because Unity copies such data by value and does not maintain the relationships between objects. We will give cells a reference to their room, and this would mean that after a recompile each cell will have its own copy of the room. While things will initially look fine, it will quickly lead to problems.<br>An alternative is to extend MonoBehaviour instead, in which case each room would be a component and we’d have to attach them to a game object, the maze being the most logical choice.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MazeRoom</span> : <span class="title">ScriptableObject</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> settingsIndex;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> MazeRoomSettings settings;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> List&lt;MazeCell&gt; cells = <span class="keyword">new</span> List&lt;MazeCell&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span> (<span class="params">MazeCell cell</span>) </span>&#123;</div><div class="line">		cell.room = <span class="keyword">this</span>;</div><div class="line">		cells.Add(cell);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-maze-room-script.png" alt=""><br>Maze room script.</p>
<p>We also give MazeCell a reference to its room. While we’re at it, let’s also give it an Initialize method that takes care of assigning the right materials. As we only have the floor quad to worry about, we just grab the first child and be done with it.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> MazeRoom room;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeRoom room</span>) </span>&#123;</div><div class="line">	room.Add(<span class="keyword">this</span>);</div><div class="line">	transform.GetChild(<span class="number">0</span>).GetComponent&lt;Renderer&gt;().material = room.settings.floorMaterial;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now add a room list and a method to create a new room to Maze. We’ll use it to create a new room for the first cell and each time we spawn a door.<br>If we were to just pick a random room type, it would be possible for two adjacent rooms to have the same type. While this is not really a problem, we get more variety by making sure that this won’t happen. This can be done by checking whether we picked the same index as the room we came from. If so, we’ll just add one to the index and wrap around. It’s biased, but that’s not a big deal here. Initially we’ll pass a negative index so any room is fine.</p>
<blockquote>
<p>What does % do?<br>The % operator computes the remainder of a division. For example, 3 % 4 is 3, 4 % 4 is zero, and 5 % 4 is 1. When used on a non-negative integer and the length of an array that has at least one element, the result will always be a valid index for that array.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;MazeRoom&gt; rooms = <span class="keyword">new</span> List&lt;MazeRoom&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> MazeRoom <span class="title">CreateRoom</span> (<span class="params"><span class="keyword">int</span> indexToExclude</span>) </span>&#123;</div><div class="line">	MazeRoom newRoom = ScriptableObject.CreateInstance&lt;MazeRoom&gt;();</div><div class="line">	newRoom.settingsIndex = Random.Range(<span class="number">0</span>, roomSettings.Length);</div><div class="line">	<span class="keyword">if</span> (newRoom.settingsIndex == indexToExclude) &#123;</div><div class="line">		newRoom.settingsIndex = (newRoom.settingsIndex + <span class="number">1</span>) % roomSettings.Length;</div><div class="line">	&#125;</div><div class="line">	newRoom.settings = roomSettings[newRoom.settingsIndex];</div><div class="line">	rooms.Add(newRoom);</div><div class="line">	<span class="keyword">return</span> newRoom;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>It is now possible to create a new room in DoFirstGenerationStep. That will take care of the first cell. To put all the other cells in a room as well, we modify CreatePassage so it checks whether a door has been placed. If so, the other cell is the first of a new room. If not, it belongs to the same room as the previous cell.</p>
<blockquote>
<p>What does is do?<br>The is operator is the companion of the as operation. Instead of casting, it tells you whether an object is of some type.</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoFirstGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	MazeCell newCell = CreateCell(RandomCoordinates);</div><div class="line">	newCell.Initialize(CreateRoom(<span class="number">-1</span>));</div><div class="line">	activeCells.Add(newCell);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreatePassage</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazePassage prefab = Random.<span class="keyword">value</span> &lt; doorProbability ? doorPrefab : passagePrefab;</div><div class="line">	MazePassage passage = Instantiate(prefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(cell, otherCell, direction);</div><div class="line">	passage = Instantiate(prefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	<span class="keyword">if</span> (passage <span class="keyword">is</span> MazeDoor) &#123;</div><div class="line">		otherCell.Initialize(CreateRoom(cell.room.settingsIndex));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		otherCell.Initialize(cell.room);</div><div class="line">	&#125;</div><div class="line">	passage.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-colored-floors.png" alt=""><br>Now with colored floors.</p>
<p>To also color the walls, we need to adjust MazeWall. Give it a reference to its wall child and configure it for all the wall prefabs that you have created. This allows us to set the wall’s material in an override of the Initialize method.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Transform wall;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">base</span>.Initialize(cell, otherCell, direction);</div><div class="line">	wall.GetComponent&lt;Renderer&gt;().material = cell.room.settings.wallMaterial;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-wall-reference.png" alt=""><br>Configuring a wall reference.</p>
<p>We have to do the same for MazeDoor, except now we set the material of all its direct children except for the hinge.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell primary, MazeCell other, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">base</span>.Initialize(primary, other, direction);</div><div class="line">	<span class="keyword">if</span> (OtherSideOfDoor != <span class="literal">null</span>) &#123;</div><div class="line">		hinge.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>f, <span class="number">1</span>f, <span class="number">1</span>f);</div><div class="line">		Vector3 p = hinge.localPosition;</div><div class="line">		p.x = -p.x;</div><div class="line">		hinge.localPosition = p;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transform.childCount; i++) &#123;</div><div class="line">		Transform child = transform.GetChild(i);</div><div class="line">		<span class="keyword">if</span> (child != hinge) &#123;</div><div class="line">			child.GetComponent&lt;Renderer&gt;().material = cell.room.settings.wallMaterial;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/10-colored-rooms.png" alt=""><br>Fully colored rooms.</p>
<h2 id="Expanding-Rooms"><a href="#Expanding-Rooms" class="headerlink" title="Expanding Rooms"></a>Expanding Rooms</h2><p>We’ve been talking about rooms all this time, but they’re really more like winding corridors. If we can prevent walls from being placed between two cell that belong to the same room, then the rooms will become more open areas.<br>Add a new CreatePassageInSameRoom method that simply creates a passage between two cells, with no chance of a door. Then update DoNextGenerationStep so it calls this method when two cells share a room, instead of placing a wall.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreatePassageInSameRoom</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazePassage passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(cell, otherCell, direction);</div><div class="line">	passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoNextGenerationStep</span> (<span class="params">List activeCells</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> currentIndex = activeCells.Count - <span class="number">1</span>;</div><div class="line">	MazeCell currentCell = activeCells[currentIndex];</div><div class="line">	<span class="keyword">if</span> (currentCell.IsFullyInitialized) &#123;</div><div class="line">		activeCells.RemoveAt(currentIndex);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	MazeDirection direction = currentCell.RandomUninitializedDirection;</div><div class="line">	IntVector2 coordinates = currentCell.coordinates + direction.ToIntVector2();</div><div class="line">	<span class="keyword">if</span> (ContainsCoordinates(coordinates)) &#123;</div><div class="line">		MazeCell neighbor = GetCell(coordinates);</div><div class="line">		<span class="keyword">if</span> (neighbor == <span class="literal">null</span>) &#123;</div><div class="line">			neighbor = CreateCell(coordinates);</div><div class="line">			CreatePassage(currentCell, neighbor, direction);</div><div class="line">			activeCells.Add(neighbor);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">currentCell.room == neighbor.room</span>) </span>&#123;</div><div class="line">			CreatePassageInSameRoom(currentCell, neighbor, direction);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			CreateWall(currentCell, neighbor, direction);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		CreateWall(currentCell, <span class="literal">null</span>, direction);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/11-open-rooms.png" alt=""><br>Some breathing room.</p>
<p>We can go a step further and even join together adjacent rooms if they share the same settings. Besides creating larger rooms that way, fusing rooms from different parts of the maze creates loops. This means that there will be multiple ways to navigate it and you could end up walking in circles.<br>All that’s really needed for this change is to relax our room comparison.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoNextGenerationStep</span> (<span class="params">List&lt;MazeCell&gt; activeCells</span>) </span>&#123;</div><div class="line">	<span class="keyword">int</span> currentIndex = activeCells.Count - <span class="number">1</span>;</div><div class="line">	MazeCell currentCell = activeCells[currentIndex];</div><div class="line">	<span class="keyword">if</span> (currentCell.IsFullyInitialized) &#123;</div><div class="line">		activeCells.RemoveAt(currentIndex);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	MazeDirection direction = currentCell.RandomUninitializedDirection;</div><div class="line">	IntVector2 coordinates = currentCell.coordinates + direction.ToIntVector2();</div><div class="line">	<span class="keyword">if</span> (ContainsCoordinates(coordinates)) &#123;</div><div class="line">		MazeCell neighbor = GetCell(coordinates);</div><div class="line">		<span class="keyword">if</span> (neighbor == <span class="literal">null</span>) &#123;</div><div class="line">			neighbor = CreateCell(coordinates);</div><div class="line">			CreatePassage(currentCell, neighbor, direction);</div><div class="line">			activeCells.Add(neighbor);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">currentCell.room.settingsIndex == neighbor.room.settingsIndex</span>) </span>&#123;</div><div class="line">			CreatePassageInSameRoom(currentCell, neighbor, direction);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			CreateWall(currentCell, neighbor, direction);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		CreateWall(currentCell, <span class="literal">null</span>, direction);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While this looks correct, we will now have different rooms with open passages connecting them. We should also get rid of one of the room instances as it is assimilated by the other. So let’s add an Assimilate method to MazeRoom.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Assimilate</span> (<span class="params">MazeRoom room</span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.cells.Count; i++) &#123;</div><div class="line">		Add(room.cells[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Then we have Maze check whether it’s connecting different rooms, in which case it assimilates and removes the other room.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreatePassageInSameRoom</span> (<span class="params">MazeCell cell, MazeCell otherCell, MazeDirection direction</span>) </span>&#123;</div><div class="line">	MazePassage passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(cell, otherCell, direction);</div><div class="line">	passage = Instantiate(passagePrefab) <span class="keyword">as</span> MazePassage;</div><div class="line">	passage.Initialize(otherCell, cell, direction.GetOpposite());</div><div class="line">	<span class="keyword">if</span> (cell.room != otherCell.room) &#123;</div><div class="line">		MazeRoom roomToAssimilate = otherCell.room;</div><div class="line">		cell.room.Assimilate(roomToAssimilate);</div><div class="line">		rooms.Remove(roomToAssimilate);</div><div class="line">		Destroy(roomToAssimilate);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/11-joined-rooms.png" alt=""><br>Now with large rooms and loops.</p>
<h2 id="Walking-Around"><a href="#Walking-Around" class="headerlink" title="Walking Around"></a>Walking Around</h2><p>It’s high time we walked around in our own maze. Create a simple player model, attach a new Player component that we create as well, and turn it into a prefab.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-player-assets.png" alt="player assets"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-player-prefab.png" alt="player-prefab"></p>
<p>A square player.</p>
<p>Give Player a public method so we can tell it what cell it’s in. Also give it an Update method that moves the player when an arrow key is pressed. Movement should only happen if the edge we would cross is a passage, otherwise we’re blocked.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MazeCell currentCell;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetLocation</span> (<span class="params">MazeCell cell</span>) </span>&#123;</div><div class="line">		currentCell = cell;</div><div class="line">		transform.localPosition = cell.transform.localPosition;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span> (<span class="params">MazeDirection direction</span>) </span>&#123;</div><div class="line">		MazeCellEdge edge = currentCell.GetEdge(direction);</div><div class="line">		<span class="keyword">if</span> (edge <span class="keyword">is</span> MazePassage) &#123;</div><div class="line">			SetLocation(edge.otherCell);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (Input.GetKeyDown(KeyCode.UpArrow)) &#123;</div><div class="line">			Move(MazeDirection.North);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.RightArrow</span>)) </span>&#123;</div><div class="line">			Move(MazeDirection.East);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.DownArrow</span>)) </span>&#123;</div><div class="line">			Move(MazeDirection.South);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.LeftArrow</span>)) </span>&#123;</div><div class="line">			Move(MazeDirection.West);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now give GameManager both a reference to the player prefab and a local reference to a current player.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">public</span> Player playerPrefab;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Player playerInstance;</div><div class="line">```			</div><div class="line"></div><div class="line">![](https:<span class="comment">//raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-game-manager.png)</span></div><div class="line">Game manager wants a player now.</div><div class="line"></div><div class="line">We should instantiate a <span class="keyword">new</span> player after the maze has finished generating. However, we currently start a coroutine and move <span class="keyword">on</span>. In order to wait, we turn BeginGame <span class="keyword">into</span> a coroutine <span class="keyword">as</span> well. Then we can <span class="keyword">yield</span> the other coroutine, so it finishes before we <span class="keyword">continue</span> ourselves and create the player and give it a random location. Also, make sure to destroy the current player <span class="keyword">in</span> RestartGame, <span class="keyword">if</span> it has already been created.</div><div class="line"></div><div class="line">```<span class="function">cs</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) &#123;</div><div class="line">		StartCoroutine(BeginGame());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> IEnumerator <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">		<span class="function"><span class="keyword">yield</span> return <span class="title">StartCoroutine</span>(<span class="params">mazeInstance.Generate(</span>))</span>;</div><div class="line">		playerInstance = Instantiate(playerPrefab) <span class="keyword">as</span> Player;</div><div class="line">		playerInstance.SetLocation(mazeInstance.GetCell(mazeInstance.RandomCoordinates));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RestartGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		StopAllCoroutines();</div><div class="line">		Destroy(mazeInstance.gameObject);</div><div class="line">		<span class="keyword">if</span> (playerInstance != <span class="literal">null</span>) &#123;</div><div class="line">			Destroy(playerInstance.gameObject);</div><div class="line">		&#125;</div><div class="line">		StartCoroutine(BeginGame());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/12-exploring.png" alt=""><br>A player exploring our maze.</p>
<h2 id="What-It-Looks-Like"><a href="#What-It-Looks-Like" class="headerlink" title="What It Looks Like"></a>What It Looks Like</h2><p>What would our maze look like, when viewing it through the eyes of the player? Let’s find out by adding a camera to the player prefab! You can do so by dragging an instance of the player prefab into the scene, creating a default camera, making it a child of the player, and then clicking the prefab Apply button of the player instance. I position the camera at a height of 0.7 and rotate it ten degrees around its X axis so it doesn’t stare straight ahead but looks a bit to the floor.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-player-camera.png" alt=""><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-player-view.png" alt=""><br>Player camera in action.</p>
<p>Keep in mind that the main camera is also still being rendered. The player camera is just rendered on top of it, because it has the default depth of zero while the default main camera has a depth of -1. Unity will also complain that there are two audio listeners in the scene at the same time, so we have to do something about that.<br>What about we keep both cameras, but turn the main camera view into a map overlay? First, remove the audio listener from the main camera and increase its depth value to one. That will make it render after and on top of the player’s camera.</p>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-main-camera.png" alt=""><br>Tweaked main camera.</p>
<p>Now we again only see the main camera as it’s rendering after the player camera. To turn it into a smaller overlay, we reduce its view rectangle after a maze has been generated. We also set it to cover the entire view before we start generating. That ensures that we get a full-size view of the maze while it is being generated.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Camera.main.rect = <span class="keyword">new</span> Rect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">1</span>f, <span class="number">1</span>f);</div><div class="line">	mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">	<span class="function"><span class="keyword">yield</span> return <span class="title">StartCoroutine</span>(<span class="params">mazeInstance.Generate(</span>))</span>;</div><div class="line">	playerInstance = Instantiate(playerPrefab) <span class="keyword">as</span> Player;</div><div class="line">	playerInstance.SetLocation(mazeInstance.GetCell(mazeInstance.RandomCoordinates));</div><div class="line">	Camera.main.rect = <span class="keyword">new</span> Rect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">0.5</span>f, <span class="number">0.5</span>f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-overlay-opaque.png" alt=""><br>An overlay map.</p>
<p>This works, but it would be nicer if the map was rendered on top of the player’s view without its own background. Fortunately, we can easily achieve this by changing the camera’s clear flags to Depth. When generating the maze, it should use its default flags value, which is SkyBox.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">BeginGame</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	Camera.main.clearFlags = CameraClearFlags.Skybox;</div><div class="line">	Camera.main.rect = <span class="keyword">new</span> Rect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">1</span>f, <span class="number">1</span>f);</div><div class="line">	mazeInstance = Instantiate(mazePrefab) <span class="keyword">as</span> Maze;</div><div class="line">	<span class="function"><span class="keyword">yield</span> return <span class="title">StartCoroutine</span>(<span class="params">mazeInstance.Generate(</span>))</span>;</div><div class="line">	playerInstance = Instantiate(playerPrefab) <span class="keyword">as</span> Player;</div><div class="line">	playerInstance.SetLocation(mazeInstance.GetCell(mazeInstance.RandomCoordinates));</div><div class="line">	Camera.main.clearFlags = CameraClearFlags.Depth;</div><div class="line">	Camera.main.rect = <span class="keyword">new</span> Rect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">0.5</span>f, <span class="number">0.5</span>f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/13-overlay-transparent.png" alt=""><br>Now without nasty background.</p>
<p>The player can move and have a map, but we are stuck looking to the north all the time. To change this, Player need to keep track of where it’s looking and respond to user input to change its rotation. Let’s use Q to rotate counterclockwise and E to rotate clockwise. While we’re at it, we can also support the common WASD key bindings.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> MazeDirection currentDirection;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Rotate</span> (<span class="params">MazeDirection direction</span>) </span>&#123;</div><div class="line">	transform.localRotation = direction.ToRotation();</div><div class="line">	currentDirection = direction;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) &#123;</div><div class="line">		Move(MazeDirection.North);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.D</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.RightArrow</span>)) </span>&#123;</div><div class="line">		Move(MazeDirection.East);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.S</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.DownArrow</span>)) </span>&#123;</div><div class="line">		Move(MazeDirection.South);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.A</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.LeftArrow</span>)) </span>&#123;</div><div class="line">		Move(MazeDirection.West);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.Q</span>)) </span>&#123;</div><div class="line">		Rotate(currentDirection.GetNextCounterclockwise());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.E</span>)) </span>&#123;</div><div class="line">		Rotate(currentDirection.GetNextClockwise());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We also add two convenient methods to MazeDirections that gives us the next direction in clockwise and counterclockwise order.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MazeDirection <span class="title">GetNextClockwise</span> (<span class="params"><span class="keyword">this</span> MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (MazeDirection)(((<span class="keyword">int</span>)direction + <span class="number">1</span>) % Count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MazeDirection <span class="title">GetNextCounterclockwise</span> (<span class="params"><span class="keyword">this</span> MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (MazeDirection)(((<span class="keyword">int</span>)direction + Count - <span class="number">1</span>) % Count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we can both move and rotate, but the movement is absolute instead of relative to our orientation. Let’s change that.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow)) &#123;</div><div class="line">		Move(currentDirection);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.D</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.RightArrow</span>)) </span>&#123;</div><div class="line">		Move(currentDirection.GetNextClockwise());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.S</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.DownArrow</span>)) </span>&#123;</div><div class="line">		Move(currentDirection.GetOpposite());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.A</span>) || Input.<span class="title">GetKeyDown</span>(<span class="params">KeyCode.LeftArrow</span>)) </span>&#123;</div><div class="line">		Move(currentDirection.GetNextCounterclockwise());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.Q</span>)) </span>&#123;</div><div class="line">		Look(currentDirection.GetNextCounterclockwise());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">Input.GetKeyDown(KeyCode.E</span>)) </span>&#123;</div><div class="line">		Look(currentDirection.GetNextClockwise());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Opening-Doors"><a href="#Opening-Doors" class="headerlink" title="Opening Doors"></a>Opening Doors</h2><p>So far we’ve been walking straight through doors without opening them. We could use various approaches to opening doors, but a simple one is to just open all doors of a cell after the player enters it, and close them again when the player exited it. In fact, other stuff might happen as well, so we’ll use a generic approach.<br>Have Player notify cells when it enters and exits them in SetLocation, by calling two new methods. Check whether there’s a cell to exit, because the first time a location is set this won’t be the case.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetLocation</span> (<span class="params">MazeCell cell</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (currentCell != <span class="literal">null</span>) &#123;</div><div class="line">		currentCell.OnPlayerExited();</div><div class="line">	&#125;</div><div class="line">	currentCell = cell;</div><div class="line">	transform.localPosition = cell.transform.localPosition;</div><div class="line">	currentCell.OnPlayerEntered();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MazeCell doesn’t do anything with those events itself, but passes them along to its edges.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.Length; i++) &#123;</div><div class="line">		edges[i].OnPlayerEntered();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerExited</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.Length; i++) &#123;</div><div class="line">		edges[i].OnPlayerExited();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We add those methods to MazeCellEdge as empty and virtual. That way nothing happens by default, but subclasses can override this.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlayerExited</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>Now we can add overrides for MazeDoor to rotate its hinge. Because there are two sides of a door, we have to rotate both of them.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	OtherSideOfDoor.hinge.localRotation = hinge.localRotation = Quaternion.Euler(<span class="number">0</span>f, <span class="number">-90</span>f, <span class="number">0</span>f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayerExited</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	OtherSideOfDoor.hinge.localRotation = hinge.localRotation = Quaternion.identity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/14-open-door.png" alt=""><br>A door opened in our face.</p>
<p>It works! Doors are now open when we stand next to them. Unfortunately the doors always rotate in the same direction. This means that about half the time the door will cut through our view in an ugly and obscuring way. We can solve this by always rotating doors away from where the player is currently standing. This can be done by remembering whether a door is mirrored and rotating based on that.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Quaternion</div><div class="line">	normalRotation = Quaternion.Euler(<span class="number">0</span>f, <span class="number">-90</span>f, <span class="number">0</span>f),</div><div class="line">	mirroredRotation = Quaternion.Euler(<span class="number">0</span>f, <span class="number">90</span>f, <span class="number">0</span>f);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">bool</span> isMirrored;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span> (<span class="params">MazeCell primary, MazeCell other, MazeDirection direction</span>) </span>&#123;</div><div class="line">	<span class="keyword">base</span>.Initialize(primary, other, direction);</div><div class="line">	<span class="keyword">if</span> (OtherSideOfDoor != <span class="literal">null</span>) &#123;</div><div class="line">		isMirrored = <span class="literal">true</span>;</div><div class="line">		hinge.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>f, <span class="number">1</span>f, <span class="number">1</span>f);</div><div class="line">		Vector3 p = hinge.localPosition;</div><div class="line">		p.x = -p.x;</div><div class="line">		hinge.localPosition = p;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transform.childCount; i++) &#123;</div><div class="line">		Transform child = transform.GetChild(i);</div><div class="line">		<span class="keyword">if</span> (child != hinge) &#123;</div><div class="line">			child.GetComponent&lt;Renderer&gt;().material = cell.room.settings.wallMaterial;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	OtherSideOfDoor.hinge.localRotation = hinge.localRotation =</div><div class="line">		isMirrored ? mirroredRotation : normalRotation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/14-open-door-away.png" alt=""><br>Always-push doors.</p>
<h2 id="Hiding-Rooms"><a href="#Hiding-Rooms" class="headerlink" title="Hiding Rooms"></a>Hiding Rooms</h2><p>An additional thing we could do is only show the room that the player is currently inside of. Besides reducing what is shown on the map, it can also eliminate lots of unnecessary draw calls for the player camera. As this functionality operates on entire rooms, let’s add Show and Hide method to MazeRoom, which call the same methods on all their cells.</p>
<blockquote>
<p>Why does obscured stuff get rendered?<br>You only need to render what you can see, right? But how do you know what you can and cannot see?<br>Unity only renders stuff that is active. Also, it only renders stuff that the camera could theoretically see, everything that lies outside of its view is not queued for rendering. The graphics card will detect when it’s about to fill a pixel that’s behind something else, so it won’t need to bother to shade it. However, we had to go all the way to the pixel level before this discovery was made, which means that we have to process lots of stuff that we end up not seeing.<br>To improve performance, some trick must be used to quickly determine what’s really visible, and only send that to the graphics card. This is known as occlusion culling and is nontrivial. Unity Pro has a solution for it, but it is not suited for randomly generated mazes. Fortunately, our simple trick of hiding rooms already helps a lot.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-much-overdraw.png" alt="without hiding"><br><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-little-overdraw.png" alt="with hiding"><br>Overdraw without hiding and with hiding rooms.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hide</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.Count; i++) &#123;</div><div class="line">		cells[i].Hide();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.Count; i++) &#123;</div><div class="line">		cells[i].Show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We let MazeCell implement this functionality by simply switching its game object on and off.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	gameObject.SetActive(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hide</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	gameObject.SetActive(<span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>And we also let Maze hide all rooms when it’s done generating.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	WaitForSeconds delay = <span class="keyword">new</span> WaitForSeconds(generationStepDelay);</div><div class="line">	cells = <span class="keyword">new</span> MazeCell[size.x, size.z];</div><div class="line">	List&lt;MazeCell&gt; activeCells = <span class="keyword">new</span> List&lt;MazeCell&gt;();</div><div class="line">	DoFirstGenerationStep(activeCells);</div><div class="line">	<span class="keyword">while</span> (activeCells.Count &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> delay;</div><div class="line">		DoNextGenerationStep(activeCells);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.Count; i++) &#123;</div><div class="line">		rooms[i].Hide();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This will place the player in an invisible maze. To make the rooms appear and disappear, we let MazeCell show and hide its room when it is entered or exited.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	room.Show();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.Length; i++) &#123;</div><div class="line">		edges[i].OnPlayerEntered();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerExited</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	room.Hide();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.Length; i++) &#123;</div><div class="line">		edges[i].OnPlayerExited();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-looking-at-hidden-room.png" alt="Looking into the void"></p>
<p>So all rooms except the one that we are currently in are now hidden. Unfortunately, this means that when we open a door we will look into an invisible room. Fortunately this is easy to solve. All we have to do is have MazeDoor show and hide the other cell’s room when it is opened and closed.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayerEntered</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	OtherSideOfDoor.hinge.localRotation = hinge.localRotation =</div><div class="line">		isMirrored ? mirroredRotation : normalRotation;</div><div class="line">	OtherSideOfDoor.cell.room.Show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayerExited</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	OtherSideOfDoor.hinge.localRotation = hinge.localRotation = Quaternion.identity;</div><div class="line">	OtherSideOfDoor.cell.room.Hide();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tospan/tospan.github.io/source/source/_images/unity/15-shown-when-door-open.png" alt="Rooms shown and hidden at the right time"></p>
<p>And indeed now rooms also show up when we could see them through an open door.<br>We can keep adding and tweaking the maze, but I will end the tutorial here. Have fun giving the maze your own special touch!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tospan.me/2017/02/06/Unity-Maze/" data-id="cizcq85an0066tdvwykvqyi33" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Basics/">Basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Games/">Games</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/06/C-Sharp-Essential/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C#要点
        
      </div>
    </a>
  
  
    <a href="/2017/02/05/Unity-Curves-and-Splines/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Unity Curves and Splines</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Development/">Game Development</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Basics/">Basics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Games/">Games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/">Geometry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linear-Algebra/">Linear Algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematics/">Mathematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numerical-Analysis/">Numerical Analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Patterns/">Patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scripting/">Scripting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/">default</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 10px;">Algorithms</a> <a href="/tags/Basics/" style="font-size: 15px;">Basics</a> <a href="/tags/C/" style="font-size: 13.33px;">C#</a> <a href="/tags/Games/" style="font-size: 10px;">Games</a> <a href="/tags/Geometry/" style="font-size: 11.67px;">Geometry</a> <a href="/tags/Linear-Algebra/" style="font-size: 16.67px;">Linear Algebra</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Mathematics/" style="font-size: 15px;">Mathematics</a> <a href="/tags/Numerical-Analysis/" style="font-size: 10px;">Numerical Analysis</a> <a href="/tags/Patterns/" style="font-size: 10px;">Patterns</a> <a href="/tags/Scripting/" style="font-size: 13.33px;">Scripting</a> <a href="/tags/Unity/" style="font-size: 20px;">Unity</a> <a href="/tags/default/" style="font-size: 18.33px;">default</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/16/Algorithms-Data-Structure/">算法:数据结构</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Sorting/">算法：排序</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Test-Bed/">搭建算法测试环境</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms-Basics/">Algorithms Basics</a>
          </li>
        
          <li>
            <a href="/2017/02/16/Algorithms/">Algorithms</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 To Span<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>